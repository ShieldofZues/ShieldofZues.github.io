<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>🏍️好好编程</title>
      <link href="/2019/12/10/%E5%BF%A0%E5%91%8A/"/>
      <url>/2019/12/10/%E5%BF%A0%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<p><strong>只要思想不滑坡，办法总比困难多！</strong><img src="https://cdn.shieldofzues.cn/2020-07-31-load.jpg" class="lazyload" data-src="https://cdn.shieldofzues.cn/2020-09-13-%E6%88%AA%E5%B1%8F2020-09-13%20%E4%B8%8B%E5%8D%886.05.17.png"  alt=""><br>💡想清楚，写清楚，说清楚，才是真正的清楚！</p><p>⏰多花点时间沟通清楚需求，才能把握正确方向！</p><p>😢修复需求错误的成本是代码错误的几十倍！</p><p>🔥程序员最大的坏习惯就是：急于动手写代码！</p><p>✈️提高开发效率的捷径：一次做对，不返工！</p><p>🤔写代码之前三件事：</p><p>   弄清楚做什么；</p><p>   说清楚怎么做；</p><p>   想清楚怎么测！</p><p>🐛职业的程序员设计程序，业余的程序员调试程序；</p><p>😫拷贝粘贴式的作业方式，最容易导入bug，最难调试！</p><p>😭重复代码是万恶之源！</p><p>👴小函数，小方法，以功能命名，可以消除注释！</p><p>😊做一点，测一点，测试驱动的开发，返工最少，返工最易；</p><p>📚一个方法的复杂度应该小于10，否则很难调试它！</p><p>🌶️随时重构代码，不遗留垃圾代码!</p><p>⚠️消除静态检查的warning和error！</p><p>🐞职业的程序员是预防BUG，业余程序员是修改BUG；</p><p>🌞经常总结自己的经验教训，写下来！汇总在一起！</p><p>🚗任何复杂的问题都可以简化，两种简化的手段：</p><p>🔪按时序拆分，按整体部分拆分；</p><p>📅每日构建，每日确认，尽早发现错误，尽早返工！ </p>]]></content>
      
      
      
        <tags>
            
            <tag> 分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日常开发本人常用idea插件分享（二）</title>
      <link href="/2019/07/23/%E6%8F%92%E4%BB%B6%E5%88%86%E4%BA%AB%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2019/07/23/%E6%8F%92%E4%BB%B6%E5%88%86%E4%BA%AB%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<hr><p>[TOC]<br><strong>多看<a href="https://www.jetbrains.com/help/idea/creating-and-optimizing-imports.html#disable-import-popups" target="_blank" rel="noopener">官方使用文档</a>还是很不错的~<br>IntelliJ IDEA的每个方面都专门设计用于最大化开发人员的工作效率。<br>强大的静态代码分析和符合人体工程学的设计使开发不仅具有高效性，而且还具有令人愉悦的体验。</strong><br><img src="https://cdn.shieldofzues.cn/2020-07-31-load.jpg" class="lazyload" data-src="https://cdn.shieldofzues.cn/2020-06-02-25.png"  alt="25.png"><br><em>插件库:</em>   <a href="http://plugins.jetbrains.com/" target="_blank" rel="noopener">官网网址</a> </p><p>两种安装方式：<br><img src="https://cdn.shieldofzues.cn/2020-07-31-load.jpg" class="lazyload" data-src="https://cdn.shieldofzues.cn/2020-06-02-21.png"  alt="21.png"></p><h2 id="1-Alibaba-Cloud-Toolkit"><a href="#1-Alibaba-Cloud-Toolkit" class="headerlink" title="1.Alibaba Cloud Toolkit"></a>1.Alibaba Cloud Toolkit</h2><blockquote><p>简介：<br>Alibaba Cloud Toolkit （后文简称 Cloud Toolkit）是针对 IDE 平台为开发者提供的一款插件，用于帮助开发者更高效地开发、测试、诊断应用和部署应用。通过 Cloud Toolkit，您可以将应用部署到云端（ECS、EDAS、容器服务 Kubernetes 等云产品）和任意服务器中去；通过内嵌的 Arthas 程序诊断、 Terminal Shell 终端和 MySQL 执行器等工具，可以快速开发、测试和诊断应用。<br>** 简言之，可将web应用等，一键部署到阿里云服务器或任意服务器下，并执行相关后续操作。**</p><blockquote><p>1.1 传统部署方式<br>在传统部署方式中，需要 7 个以上的步骤才能完成部署，并且在本地 IDE、云产品控制台、Git/SVN、Maven/Gradle、镜像仓库、ECS、容器等多个产品间来回切换。<br><img src="https://cdn.shieldofzues.cn/2020-07-31-load.jpg" class="lazyload" data-src="https://cdn.shieldofzues.cn/2020-06-02-22.png"  alt="22.png"><br>1.2  Cloud Toolkit 部署方式(<em>优势</em>)<br>在使用 Cloud Toolkit 的部署方式中，插件自动化了项目构建、SCP 上传部署包、制作 Docker Image、登录机器、推送至镜像仓库等多个步骤。您只需要在第一次使用时在本地 IDE 上安装 Cloud Toolkit，即可快速部署。<br>1.3 下载链接及官方使用教程</p><blockquote><p><a href="https://www.aliyun.com/product/cloudtoolkit" target="_blank" rel="noopener">官网视频演示及相关内容介绍地址</a><br><a href="http://plugins.jetbrains.com/plugin/11386-alibaba-cloud-toolkit" target="_blank" rel="noopener">插件下载链接</a></p></blockquote></blockquote></blockquote><h2 id="2-Alibaba-Java-Coding-Guidelines"><a href="#2-Alibaba-Java-Coding-Guidelines" class="headerlink" title="2.Alibaba Java Coding Guidelines"></a>2.Alibaba Java Coding Guidelines</h2><blockquote><blockquote><p>2.1 下载链接及官方使用教程（支持eclipse）<br>配合《阿里巴巴Java开发手册》还是很值的使用的~</p><blockquote><p><a href="https://github.com/alibaba/p3c" target="_blank" rel="noopener">源码地址</a><br><a href="https://github.com/alibaba/p3c/wiki/IDEA%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3" target="_blank" rel="noopener">使用教程</a><br><a href="http://plugins.jetbrains.com/plugin/10046-alibaba-java-coding-guidelines" target="_blank" rel="noopener">插件下载链接</a></p></blockquote></blockquote></blockquote><h2 id="3-RestfulToolkit（需Spring体系）"><a href="#3-RestfulToolkit（需Spring体系）" class="headerlink" title="3.RestfulToolkit（需Spring体系）"></a>3.RestfulToolkit（需Spring体系）</h2><blockquote><p>简介：一套 RESTful 服务开发辅助工具集。</p><blockquote><p>1.根据 URL 直接跳转到对应的方法定义 ( Ctrl \ or Ctrl Alt N );<br>2.提供了一个 Services tree 的显示窗口;<br>3.一个简单的 http 请求工具;<br>4.在请求方法上添加了有用功能: 复制生成 URL;,复制方法参数…<br>5.其他功能: java 类上添加 Convert to JSON 功能，格式化 json 数据 ( Windows: Ctrl + Enter; Mac: Command + Enter )。<br>支持 Spring 体系 (Spring MVC / Spring Boot 1.x,2.x)<br>支持 JAX-RS<br>支持 Java 和 Kotlin 语言。</p></blockquote></blockquote><blockquote><p>3.1 效果图及使用方法<br><img src="https://cdn.shieldofzues.cn/2020-07-31-load.jpg" class="lazyload" data-src="https://cdn.shieldofzues.cn/2020-06-02-23.png"  alt=""><br>3.2 插件下载地址</p><blockquote><p><a href="https://plugins.jetbrains.com/plugin/10292-restfultoolkit" target="_blank" rel="noopener">插件下载链接</a></p></blockquote></blockquote><h2 id="4-SonarLint"><a href="#4-SonarLint" class="headerlink" title="4.SonarLint"></a>4.SonarLint</h2><blockquote><p>简介：想不想身边有个“大神”指导你开发？它就可以满足你<del>不错的代码质量检测插件，帮你检测代码中的“坏味道</del>”。</p><blockquote><p><a href="https://www.sonarlint.org/" target="_blank" rel="noopener">官网-需墙</a><br><a href="https://blog.sonarsource.com/" target="_blank" rel="noopener">博客-需墙</a></p></blockquote></blockquote><blockquote><p>4.1 效果图<br><img src="https://cdn.shieldofzues.cn/2020-07-31-load.jpg" class="lazyload" data-src="https://cdn.shieldofzues.cn/2020-06-02-24.png"  alt=""><br>4.2 插件下载地址</p><blockquote><p><a href="https://plugins.jetbrains.com/plugin/7973-sonarlint/" target="_blank" rel="noopener">插件下载链接</a></p></blockquote></blockquote><h2 id="5-更多插件"><a href="#5-更多插件" class="headerlink" title="5.更多插件"></a>5.更多插件</h2><p>关于各个插件如何使用的问题，下载链接中一般都会有一些简单的gif演示；或自行按需要找一找便可，这里不一一赘述。</p><table><thead><tr><th>插件名称</th><th>插件介绍</th><th>插件下载地址</th></tr></thead><tbody><tr><td>Gitee</td><td>开源中国的码云插件</td><td><a href="https://plugins.jetbrains.com/plugin/8383-gitee" target="_blank" rel="noopener">https://plugins.jetbrains.com/plugin/8383-gitee</a></td></tr><tr><td></td><td></td><td></td></tr><tr><td>IDE Features Trainer</td><td>IntelliJ IDEA 官方出的学习辅助插件</td><td><a href="https://plugins.jetbrains.com/plugin/8554?pr=idea" target="_blank" rel="noopener">https://plugins.jetbrains.com/plugin/8554?pr=idea</a></td></tr><tr><td></td><td></td><td></td></tr><tr><td>Key promoter</td><td>快捷键提示</td><td><a href="https://plugins.jetbrains.com/plugin/4455?pr=idea" target="_blank" rel="noopener">https://plugins.jetbrains.com/plugin/4455?pr=idea</a></td></tr><tr><td></td><td></td><td></td></tr><tr><td>Grep Console</td><td>自定义设置控制台输出颜色</td><td><a href="https://plugins.jetbrains.com/idea/plugin/7125-grep-console" target="_blank" rel="noopener">https://plugins.jetbrains.com/idea/plugin/7125-grep-console</a></td></tr><tr><td></td><td></td><td></td></tr><tr><td>String Manipulation</td><td>驼峰式命名和下划线命名交替变化</td><td><a href="https://plugins.jetbrains.com/plugin/2162?pr=idea" target="_blank" rel="noopener">https://plugins.jetbrains.com/plugin/2162?pr=idea</a></td></tr><tr><td></td><td></td><td></td></tr><tr><td>CheckStyle-IDEA</td><td>代码规范检查</td><td><a href="https://plugins.jetbrains.com/plugin/1065?pr=idea" target="_blank" rel="noopener">https://plugins.jetbrains.com/plugin/1065?pr=idea</a></td></tr><tr><td></td><td></td><td></td></tr><tr><td>FindBugs-IDEA</td><td>潜在 Bug 检查</td><td><a href="https://plugins.jetbrains.com/plugin/3847?pr=idea" target="_blank" rel="noopener">https://plugins.jetbrains.com/plugin/3847?pr=idea</a></td></tr><tr><td></td><td></td><td></td></tr><tr><td>MetricsReloaded</td><td>代码复杂度检查</td><td><a href="https://plugins.jetbrains.com/plugin/93?pr=idea" target="_blank" rel="noopener">https://plugins.jetbrains.com/plugin/93?pr=idea</a></td></tr><tr><td></td><td></td><td></td></tr><tr><td>Statistic</td><td>代码统计</td><td><a href="https://plugins.jetbrains.com/plugin/4509?pr=idea" target="_blank" rel="noopener">https://plugins.jetbrains.com/plugin/4509?pr=idea</a></td></tr><tr><td></td><td></td><td></td></tr><tr><td>JRebel Plugin</td><td>热部署</td><td><a href="https://plugins.jetbrains.com/plugin/?id=4441" target="_blank" rel="noopener">https://plugins.jetbrains.com/plugin/?id=4441</a></td></tr><tr><td></td><td></td><td></td></tr><tr><td>CodeGlance</td><td>在编辑代码最右侧，显示一块代码小地图</td><td><a href="https://plugins.jetbrains.com/plugin/7275?pr=idea" target="_blank" rel="noopener">https://plugins.jetbrains.com/plugin/7275?pr=idea</a></td></tr><tr><td></td><td></td><td></td></tr><tr><td>GsonFormat</td><td>把 JSON 字符串直接实例化成类</td><td><a href="https://plugins.jetbrains.com/plugin/7654?pr=idea" target="_blank" rel="noopener">https://plugins.jetbrains.com/plugin/7654?pr=idea</a></td></tr><tr><td></td><td></td><td></td></tr><tr><td>Markdown Navigator</td><td>书写 Markdown 文章</td><td><a href="https://plugins.jetbrains.com/plugin/7896?pr=idea" target="_blank" rel="noopener">https://plugins.jetbrains.com/plugin/7896?pr=idea</a></td></tr><tr><td></td><td></td><td></td></tr><tr><td>Eclipse Code Formatter</td><td>使用 Eclipse 的代码格式化风格，在一个团队中如果公司有规定格式化风格，这个可以使用。</td><td><a href="https://plugins.jetbrains.com/plugin/6546?pr=idea" target="_blank" rel="noopener">https://plugins.jetbrains.com/plugin/6546?pr=idea</a></td></tr><tr><td></td><td></td><td></td></tr><tr><td>Jindent-Source Code Formatter</td><td>自定义类、方法、doc、变量注释模板</td><td><a href="http://plugins.jetbrains.com/plugin/2170?pr=idea" target="_blank" rel="noopener">http://plugins.jetbrains.com/plugin/2170?pr=idea</a></td></tr><tr><td></td><td></td><td></td></tr><tr><td>Translation</td><td>翻译插件</td><td><a href="https://github.com/YiiGuxing/TranslationPlugin" target="_blank" rel="noopener">https://github.com/YiiGuxing/TranslationPlugin</a></td></tr><tr><td></td><td></td><td></td></tr><tr><td>Maven Helper</td><td>Maven 辅助插件</td><td><a href="https://plugins.jetbrains.com/plugin/7179-maven-helper" target="_blank" rel="noopener">https://plugins.jetbrains.com/plugin/7179-maven-helper</a></td></tr><tr><td></td><td></td><td></td></tr><tr><td>Properties to YAML Converter</td><td>把 Properties 的配置格式改为 YAML 格式</td><td><a href="https://plugins.jetbrains.com/plugin/8000-properties-to-yaml-converter" target="_blank" rel="noopener">https://plugins.jetbrains.com/plugin/8000-properties-to-yaml-converter</a></td></tr><tr><td></td><td></td><td></td></tr><tr><td>Git Flow Integration</td><td>Git Flow 的图形界面操作</td><td><a href="https://plugins.jetbrains.com/plugin/7315-git-flow-integration" target="_blank" rel="noopener">https://plugins.jetbrains.com/plugin/7315-git-flow-integration</a></td></tr><tr><td></td><td></td><td></td></tr><tr><td>Rainbow Brackets</td><td>对各个对称括号进行着色，方便查看</td><td><a href="https://github.com/izhangzhihao/intellij-rainbow-brackets" target="_blank" rel="noopener">https://github.com/izhangzhihao/intellij-rainbow-brackets</a></td></tr><tr><td></td><td></td><td></td></tr><tr><td>Free Mybatis plugin</td><td>xml与mapper间跳转（免费）</td><td><a href="https://plugins.jetbrains.com/plugin/8321-free-mybatis-plugin" target="_blank" rel="noopener">https://plugins.jetbrains.com/plugin/8321-free-mybatis-plugin</a></td></tr><tr><td></td><td></td><td></td></tr><tr><td>Lombok Plugin</td><td>Lombok 功能辅助插件（@Data等）</td><td><a href="https://plugins.jetbrains.com/plugin/6317-lombok-plugin" target="_blank" rel="noopener">https://plugins.jetbrains.com/plugin/6317-lombok-plugin</a></td></tr><tr><td></td><td></td><td></td></tr><tr><td>.ignore</td><td>各类版本控制忽略文件生成工具</td><td><a href="https://plugins.jetbrains.com/plugin/7495--ignore" target="_blank" rel="noopener">https://plugins.jetbrains.com/plugin/7495--ignore</a></td></tr><tr><td></td><td></td><td></td></tr><tr><td>mongo4idea</td><td>mongo客户端</td><td><a href="https://github.com/dboissier/mongo4idea" target="_blank" rel="noopener">https://github.com/dboissier/mongo4idea</a></td></tr><tr><td></td><td></td><td></td></tr><tr><td>iedis</td><td>redis客户端</td><td><a href="https://plugins.jetbrains.com/plugin/9228-iedis" target="_blank" rel="noopener">https://plugins.jetbrains.com/plugin/9228-iedis</a></td></tr><tr><td></td><td></td><td></td></tr><tr><td>GenerateAllSetter</td><td>new POJO类的快速生成 set 方法</td><td><a href="https://plugins.jetbrains.com/plugin/9360-generateallsetter" target="_blank" rel="noopener">https://plugins.jetbrains.com/plugin/9360-generateallsetter</a></td></tr><tr><td></td><td></td><td></td></tr><tr><td>MyBatis Log Plugin</td><td>将 Mybatis 执行的 sql 脚本显示出来，无需处理，可以直接复制出来执行的</td><td><a href="https://plugins.jetbrains.com/plugin/10065-mybatis-log-plugin" target="_blank" rel="noopener">https://plugins.jetbrains.com/plugin/10065-mybatis-log-plugin</a></td></tr><tr><td></td><td></td><td></td></tr><tr><td>stackoverflow</td><td>这一看似平淡的右键 stackoverflow，却把其中的闷骚体现的淋漓尽致：我就这么叼，我就不去浏览器里查，只有右键才和我的右手匹配。</td><td><a href="https://plugins.jetbrains.com/plugin/9513-stackoverflow" target="_blank" rel="noopener">https://plugins.jetbrains.com/plugin/9513-stackoverflow</a></td></tr><tr><td></td><td></td><td></td></tr><tr><td>Nyan progress bar</td><td>普通的人进度条都太普通，我的精致要装扮到每一个细节，包括进度条！</td><td><a href="https://plugins.jetbrains.com/plugin/8575-nyan-progress-bar" target="_blank" rel="noopener">https://plugins.jetbrains.com/plugin/8575-nyan-progress-bar</a></td></tr><tr><td></td><td></td><td></td></tr><tr><td>activate-power-mode</td><td>炫酷的输入效果（带震动效果）同类型的还有冒火焰的 Power Mode II</td><td><a href="https://plugins.jetbrains.com/plugin/8330-activate-power-mode" target="_blank" rel="noopener">https://plugins.jetbrains.com/plugin/8330-activate-power-mode</a></td></tr><tr><td></td><td></td><td></td></tr><tr><td>Material Theme UI</td><td>Material Theme UI 是 JetBrains IDE（IntelliJ IDEA，WebStorm，Android Studio 等）的插件，可将原始外观更改为 Material Design 外观。</td><td><a href="https://plugins.jetbrains.com/plugin/8006-material-theme-ui" target="_blank" rel="noopener">https://plugins.jetbrains.com/plugin/8006-material-theme-ui</a></td></tr><tr><td><a href="#top">top</a></td><td></td><td></td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> 分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用浏览器插件分享（一）</title>
      <link href="/2019/07/23/%E6%8F%92%E4%BB%B6%E5%88%86%E4%BA%AB%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2019/07/23/%E6%8F%92%E4%BB%B6%E5%88%86%E4%BA%AB%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><em>写在最前面：安装“谷歌浏览器”以下插件的前提-先墙，推荐蓝灯 链接如：<a href="https://github.com/getlantern/lantern" target="_blank" rel="noopener">lantern</a> 使用方法很简单，点击启动即可。</em><br><strong>谷歌浏览器&gt;更多工具&gt;扩展程序&gt;（访问需墙）打开Chorm网上应用店</strong><br><img src="https://cdn.shieldofzues.cn/2020-07-31-load.jpg" class="lazyload" data-src="https://cdn.shieldofzues.cn/2020-06-02-1.png"  alt="1.png"></p><p>大部分在GitHub上均有托管，感兴趣可以去找找看，没准儿有不一样的灵感~</p><h3 id="1-1-谷歌访问助手-PP谷歌访问助手"><a href="#1-1-谷歌访问助手-PP谷歌访问助手" class="headerlink" title="1.1 谷歌访问助手/PP谷歌访问助手"></a>1.1 谷歌访问助手/PP谷歌访问助手</h3><p>谷歌访问助手效果图为例：<br><img src="https://cdn.shieldofzues.cn/2020-07-31-load.jpg" class="lazyload" data-src="https://cdn.shieldofzues.cn/2020-06-02-2.png"  alt="2.png"></p><p><em>(建议先安装，之后可以借助其翻墙，类似插件还要好多<del>需要你自己去发现</del>)</em></p><p>最简单易用的谷歌访问助手,为chrome扩展用户量身打造。可以解决chrome扩展无法自动更新的问题，同时可以访问谷歌google搜索，gmail邮箱；<br>帮助访问Google网站，永久免费，不限时。简单，好用。可更快的访问Google搜索，Gmail邮箱，Google翻译，Google地图，Google Docs文档等。</p><h3 id="1-2-JSON-handle"><a href="#1-2-JSON-handle" class="headerlink" title="1.2 JSON-handle"></a>1.2 JSON-handle</h3><p>效果图：<br><img src="https://cdn.shieldofzues.cn/2020-07-31-load.jpg" class="lazyload" data-src="https://cdn.shieldofzues.cn/2020-06-02-3.png"  alt="3.png"></p><p>对JSON格式的内容进行浏览和编辑，以树形图样式展现JSON文档，并可实时编辑。</p><h3 id="1-4-Axure-RP-Extension-for-Chrome"><a href="#1-4-Axure-RP-Extension-for-Chrome" class="headerlink" title="1.4 Axure RP Extension for Chrome"></a>1.4 Axure RP Extension for Chrome</h3><p>Axure RP Extension for Chrome是一款谷歌插件，用来查看原型文件。</p><h3 id="1-5-Octotree"><a href="#1-5-Octotree" class="headerlink" title="1.5 Octotree"></a>1.5 Octotree</h3><p>效果图：<br><img src="https://cdn.shieldofzues.cn/2020-07-31-load.jpg" class="lazyload" data-src="https://cdn.shieldofzues.cn/2020-06-02-4.png"  alt="4.png"></p><p>浏览器扩展（Chrome，Firefox，Opera和Safari）在GitHub和GitLab上显示代码树。 非常棒的探索项目源而无需将每个存储库都拉到您的机器上。 特征：</p><p>易于导航的代码树，就像在IDE中一样<br>使用pjax和Turbolinks快速浏览<br>支持私有存储库（请参阅说明）<br>支持GitHub和GitLab Enterprise（仅限Chrome和Opera，请参阅说明）</p><h3 id="1-6-WEB前端助手-FeHelper"><a href="#1-6-WEB前端助手-FeHelper" class="headerlink" title="1.6 WEB前端助手(FeHelper)"></a>1.6 WEB前端助手(FeHelper)</h3><p>效果图：<br><img src="https://cdn.shieldofzues.cn/2020-07-31-load.jpg" class="lazyload" data-src="https://cdn.shieldofzues.cn/2020-06-02-5.png"  alt="5.png"></p><p>FE助手：包括字符串编解码、代码压缩、美化、JSON格式化、正则表达式、时间转换工具、二维码生成与解码、编码规范检测、页面性能检测、页面取色、Ajax接口调试</p><h3 id="1-7-Sourcegraph"><a href="#1-7-Sourcegraph" class="headerlink" title="1.7 Sourcegraph"></a>1.7 Sourcegraph</h3><p>效果图：<br><img src="https://cdn.shieldofzues.cn/2020-07-31-load.jpg" class="lazyload" data-src="https://cdn.shieldofzues.cn/2020-06-02-6.png"  alt="6.png"></p><p>Sourcegraph 被大众广为熟知正是因为它支持在 GitHub 上轻松浏览和搜索代码，Sourcegraph 这款 Chrome 插件称得上是开发者必备的插件，它可以让我们像使用 IDE 一样浏览和搜索 GitHub 代码。Sourcegraph 是一款能够根据语义来把 Web 上的开源代码编入索引的代码搜索浏览工具。你可以从代码仓库和安装包，甚至是函数里搜索代码，同时也可以直接点击被完全创建了链接的代码来阅读文档、跳转到变量定义或者马上找到可用的 Demo。总而言之，你可以在你的 Web 浏览器上完成这一切，而不需要配置任何编辑器。由 Sourcegraph 出品的这款 Chrome 插件，可以非常方便地浏览和搜索 GitHub 上的代码，持跨仓库(repository)搜索、跳转到定义、查找引用等功能，宛若一个功能强大的 IDE。核心功能如跳转到定义(Go-to-definition) —— 浏览文件或查看 pull 请求时，将鼠标悬停在代码上可以查看文档提示，单击即可跳转到定义、查找引用或全文搜索。</p><h3 id="1-8-其它插件"><a href="#1-8-其它插件" class="headerlink" title="1.8 其它插件"></a>1.8 其它插件</h3><p>作为后端开发，常用的接口测试插件Postman本想单独列一下，后来想想还是算了吧！什么年代了~ 现在swagger2接口模式这么主流，再整合诸如<a href="https://github.com/YMFE/yapi" target="_blank" rel="noopener">Yapi</a>之类的可视化接口管理平台，根本没postman什么事了吧[捂脸苦笑]~</p><p> 还有其它各种插件，这里不再一一赘述，Google在手！天下我有！<a href="#top">top</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码生成</title>
      <link href="/2019/07/02/%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/"/>
      <url>/2019/07/02/%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/ShieldofZues/-springboot-tk.mybatis-lombok/tree/master/demo" target="_blank" rel="noopener">源码地址</a><br>(maven插件的形式)通用mapper快速生成项目所需ENTITY（集成swagger2的包含@ApiModel、 @Data 、@Builder 、@Table注解）MODEL层、MAPPER(DAO)层、*MAPPER.XML等—-简单demo,简化代码、快捷开发</p><h1 id="springboot-tk-mybatis-lombok-myBatisGeneratorPlugins"><a href="#springboot-tk-mybatis-lombok-myBatisGeneratorPlugins" class="headerlink" title="springboot-tk.mybatis-lombok-myBatisGeneratorPlugins"></a>springboot-tk.mybatis-lombok-myBatisGeneratorPlugins</h1><p>1、基于通用mapper插件，快速根据数据库表生成项目所需ENTITY(MODEL)层、MAPPER(DAO)层、*MAPPER.XML等</p><p>2、核心文件的MyBatis-generator.xml及的pom.xml中依赖的配置</p><p>3、目录结构供参考</p><p>使用方法:<br>1.MAVEN项目的pom.xml中引入相关插件及依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!----maven编译插件---&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!----mybatis-generator插件---&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!----指向项目目录下的mybatis-generator.xml生成配置---&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">configurationFile</span>&gt;</span></span><br><span class="line">             $&#123;basedir&#125;/src/main/resources/mybatis-generator.xml</span><br><span class="line">         <span class="tag">&lt;/<span class="name">configurationFile</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">overwrite</span>&gt;</span>true<span class="tag">&lt;/<span class="name">overwrite</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">verbose</span>&gt;</span>true<span class="tag">&lt;/<span class="name">verbose</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!---执行mybatis-generator插件时,需要提供的数据库驱动程序依赖---&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.29<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!---通用mappery依赖---&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>tk.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!---lombok相关依赖---&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.softwareloop<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-lombok-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.misterchangray.mybatis.generator.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>myBatisGeneratorPlugins<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.MyBatis-generator.xml中主要引入插件如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span> <span class="attr">type</span>=<span class="string">"com.softwareloop.mybatis.generator.plugins.LombokPlugin"</span>&gt;</span></span><br><span class="line">           <span class="comment">&lt;!-- enable annotations --&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"builder"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">           <span class="comment">&lt;!-- annotation's option(boolean) --&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"builder.fluent"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">           <span class="comment">&lt;!-- annotation's option(String) --&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"builder.builderMethodName"</span> <span class="attr">value</span>=<span class="string">"myBuilder"</span>/&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"accessors"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">           <span class="comment">&lt;!-- annotation's option(array of String) --&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"accessors.prefix"</span> <span class="attr">value</span>=<span class="string">"m_, _"</span>/&gt;</span></span><br><span class="line">           <span class="comment">&lt;!-- disable annotations --&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"allArgsConstructor"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 自动为entity生成swagger2文档--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">type</span>=<span class="string">"mybatis.generator.plugins.GeneratorSwagger2Doc"</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"apiModelAnnotationPackage"</span> <span class="attr">value</span>=<span class="string">"io.swagger.annotations.ApiModel"</span>/&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"apiModelPropertyAnnotationPackage"</span> <span class="attr">value</span>=<span class="string">"io.swagger.annotations.ApiModelProperty"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">type</span>=<span class="string">"tk.mybatis.mapper.generator.MapperPlugin"</span>&gt;</span></span><br><span class="line">           <span class="comment">&lt;!---如果有自定义BaseMapper,此处的 BaseMapper注意一定不能被扫描到,此处也可以直接引用通用mapper---&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mappers"</span> <span class="attr">value</span>=<span class="string">"com.example.demo.common.BaseMapper"</span>/&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"caseSensitive"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suppressTypeWarnings"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"forceAnnotation"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"generateColumnConsts"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p>【说明】：网上有很多说法，可直接添加property来做lombok注解的生成，但我尝试过，不太好用，不知是否是版本的原因还是其他原因—-所以才引入的LombokPlugin插件来进行注解的自动生成</p><pre><code class="xml"><span class="comment">&lt;!--配置是否启用lombok, 支持如下6种注解--&gt;</span><span class="comment">&lt;!--当配置 Data 后，Getter Setter ToString EqualsAndHashCode 会被忽略--&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"lombok"</span> <span class="attr">value</span>=<span class="string">"Getter,Setter,Data,ToString,Accessors,EqualsAndHashCode"</span>/&gt;</span></code></pre><p>【特别注意】：关于MyBatis-generator.xml中涉及的插件或属性等在demo中均有具体注释说明，可按自己需求进行引用。</p>]]></content>
      
      
      <categories>
          
          <category> mapper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mapper </tag>
            
            <tag> coding </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>升级swagger2.9.2 报错： java.lang.NumberFormatException 解决</title>
      <link href="/2019/07/02/swagger/"/>
      <url>/2019/07/02/swagger/</url>
      
        <content type="html"><![CDATA[<p>此处是”老外”的BB叨：<a href="https://github.com/springfox/springfox/issues/2265" target="_blank" rel="noopener">https://github.com/springfox/springfox/issues/2265</a><br>异常截图：<img src="https://cdn.shieldofzues.cn/2020-07-31-load.jpg" class="lazyload" data-src="https://cdn.shieldofzues.cn/2020-06-02-053326.png"  alt=""><br>进源码发现 <img src="https://cdn.shieldofzues.cn/2020-07-31-load.jpg" class="lazyload" data-src="https://cdn.shieldofzues.cn/2020-06-02-053359.png"  alt=""><br>在使用@ApiModelProperty(value = “xx” , example=”xx “)注解时，会校验实体属性类型，若该类型是Integer，example默认为””导致转换异常。<br>解决办法（测试有效）：排除springfox-swagger2 引入的swagger-annotations、swagger-models 1.5.20版本，手动引入1.5.21版本的jar。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springfox-swagger2&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.9.2&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;groupId&gt;io.swagger&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;swagger-annotations&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;exclusion&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;groupId&gt;io.swagger&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;swagger-models&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;exclusion&gt;</span><br><span class="line">    &lt;&#x2F;exclusions&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springfox-swagger-ui&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.9.2&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.swagger&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;swagger-annotations&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.5.21&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.swagger&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;swagger-models&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.5.21&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> swagger </category>
          
      </categories>
      
      
        <tags>
            
            <tag> idea </tag>
            
            <tag> swagger </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录mysql查询过去十二个月中每个月的数据情况（含本月）</title>
      <link href="/2019/03/01/mysql/"/>
      <url>/2019/03/01/mysql/</url>
      
        <content type="html"><![CDATA[<p>思路：创建视图，查询过去的12个月；当然，也可以使用存储过程遍历的把12个月插入到一个临时表中。</p><p>一、以视图的形式实现</p><p>1.1创建过去十二个月的视图SQL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> </span><br><span class="line">    ALGORITHM = UNDEFINED </span><br><span class="line">    DEFINER = <span class="string">`root`</span>@<span class="string">`%`</span> </span><br><span class="line">    <span class="keyword">SQL</span> <span class="keyword">SECURITY</span> DEFINER</span><br><span class="line"><span class="keyword">VIEW</span> <span class="string">`year_month_view`</span> <span class="keyword">AS</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">DATE_FORMAT</span>(<span class="keyword">CURDATE</span>(), <span class="string">'%Y-%m'</span>) <span class="keyword">AS</span> <span class="string">`year_month`</span> </span><br><span class="line">    <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="keyword">DATE_FORMAT</span>((<span class="keyword">CURDATE</span>() - <span class="built_in">INTERVAL</span> <span class="number">1</span> <span class="keyword">MONTH</span>), <span class="string">'%Y-%m'</span>) <span class="keyword">AS</span> <span class="string">`year_month`</span> </span><br><span class="line">    <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="keyword">DATE_FORMAT</span>((<span class="keyword">CURDATE</span>() - <span class="built_in">INTERVAL</span> <span class="number">2</span> <span class="keyword">MONTH</span>), <span class="string">'%Y-%m'</span>) <span class="keyword">AS</span> <span class="string">`year_month`</span> </span><br><span class="line">    <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="keyword">DATE_FORMAT</span>((<span class="keyword">CURDATE</span>() - <span class="built_in">INTERVAL</span> <span class="number">3</span> <span class="keyword">MONTH</span>), <span class="string">'%Y-%m'</span>) <span class="keyword">AS</span> <span class="string">`year_month`</span> </span><br><span class="line">    <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="keyword">DATE_FORMAT</span>((<span class="keyword">CURDATE</span>() - <span class="built_in">INTERVAL</span> <span class="number">4</span> <span class="keyword">MONTH</span>), <span class="string">'%Y-%m'</span>) <span class="keyword">AS</span> <span class="string">`year_month`</span> </span><br><span class="line">    <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="keyword">DATE_FORMAT</span>((<span class="keyword">CURDATE</span>() - <span class="built_in">INTERVAL</span> <span class="number">5</span> <span class="keyword">MONTH</span>), <span class="string">'%Y-%m'</span>) <span class="keyword">AS</span> <span class="string">`year_month`</span> </span><br><span class="line">    <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="keyword">DATE_FORMAT</span>((<span class="keyword">CURDATE</span>() - <span class="built_in">INTERVAL</span> <span class="number">6</span> <span class="keyword">MONTH</span>), <span class="string">'%Y-%m'</span>) <span class="keyword">AS</span> <span class="string">`year_month`</span> </span><br><span class="line">    <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="keyword">DATE_FORMAT</span>((<span class="keyword">CURDATE</span>() - <span class="built_in">INTERVAL</span> <span class="number">7</span> <span class="keyword">MONTH</span>), <span class="string">'%Y-%m'</span>) <span class="keyword">AS</span> <span class="string">`year_month`</span> </span><br><span class="line">    <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="keyword">DATE_FORMAT</span>((<span class="keyword">CURDATE</span>() - <span class="built_in">INTERVAL</span> <span class="number">8</span> <span class="keyword">MONTH</span>), <span class="string">'%Y-%m'</span>) <span class="keyword">AS</span> <span class="string">`year_month`</span> </span><br><span class="line">    <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="keyword">DATE_FORMAT</span>((<span class="keyword">CURDATE</span>() - <span class="built_in">INTERVAL</span> <span class="number">9</span> <span class="keyword">MONTH</span>), <span class="string">'%Y-%m'</span>) <span class="keyword">AS</span> <span class="string">`year_month`</span> </span><br><span class="line">    <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="keyword">DATE_FORMAT</span>((<span class="keyword">CURDATE</span>() - <span class="built_in">INTERVAL</span> <span class="number">10</span> <span class="keyword">MONTH</span>), <span class="string">'%Y-%m'</span>) <span class="keyword">AS</span> <span class="string">`year_month`</span> </span><br><span class="line">    <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="keyword">DATE_FORMAT</span>((<span class="keyword">CURDATE</span>() - <span class="built_in">INTERVAL</span> <span class="number">11</span> <span class="keyword">MONTH</span>), <span class="string">'%Y-%m'</span>) <span class="keyword">AS</span> <span class="string">`year_month`</span></span><br></pre></td></tr></table></figure><p>关于sql中用到的视图语法说明及视图说明：</p><p>a、ALGORITHM可取三个值：MERGE、TEMPTABLE或UNDEFINED。</p><p>如果没有ALGORITHM子句，默认算法是UNDEFINED（未定义的）。算法会影响MySQL处理视图的方式。</p><p>对于MERGE，会将引用视图的语句的文本与视图定义合并起来，使得视图定义的某一部分取代语句的对应部分。</p><p>对于TEMPTABLE，视图的结果将被置于临时表中，然后使用它执行语句。</p><p>对于UNDEFINED，MySQL自己选择所要使用的算法。如果可能，它倾向于MERGE而不是TEMPTABLE，</p><p>这是因为MERGE通常更有效，而且如果使用了临时表，视图是不可更新的。</p><p>b、DEFINER 表示按定义者拥有的权限来执行（指定视图创建者）</p><pre><code>INVOKER 表示用调用者的权限来执行。默认情况下，系统指定为DEFINER </code></pre><p>c、SQL SECURITY DEFINER：指定视图查询数据时的安全验证方式；</p><p>语法一<br>DATE_FORMAT(date,format)<br>date 参数是合法的日期。format 规定日期/时间的输出格式。<br>语法二<br>CURDATE()函数返回当前的日期。<br>INTERVAL </p><p>详情链接：</p><p>效果如图：创建完成查看视图sql</p><p>select ym.year_month from year_month_view ym group by ym.year_month;<br><img src="https://cdn.shieldofzues.cn/2020-07-31-load.jpg" class="lazyload" data-src="https://cdn.shieldofzues.cn/2020-06-02-060737.png"  alt=""><br>1.2 关联查询数据sql</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">ymv.year_month yearMonth,</span><br><span class="line"><span class="keyword">ifnull</span>(pi.totalPay, <span class="number">0</span>) totalPay</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">year_month_view ymv</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> (</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">DATE_FORMAT</span>(pi.in_Issu_time, <span class="string">'%Y-%m'</span>) yearMonth,</span><br><span class="line"><span class="keyword">SUM</span>(pi.total_Tax_included_Am) totalPay</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">pj_invoice <span class="keyword">pi</span></span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line"><span class="keyword">DATE_FORMAT</span>(pi.in_Issu_time, <span class="string">'%Y-%m'</span>) &gt; <span class="keyword">DATE_FORMAT</span>(</span><br><span class="line"><span class="keyword">date_sub</span>(<span class="keyword">curdate</span>(), <span class="built_in">INTERVAL</span> <span class="number">12</span> <span class="keyword">MONTH</span>),</span><br><span class="line"><span class="string">'%Y-%m'</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">yearMonth</span><br><span class="line">) <span class="keyword">pi</span> <span class="keyword">ON</span> ymv.year_month = pi.yearMonth</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">ymv.year_month</span><br></pre></td></tr></table></figure><p>说明：sql对应in_Issu_time是我业务表中对应的某个时间，具体业务是查询过去一年中每个月的数据的总额。</p><p>pj对应的要查询的数据业务表、year_month_view视图、total_Tax_included_Am每条记录的总额度、计算出的总额totalPay</p><p>DATE_SUB(d,INTERVAL expr type)函数返回起始日期d减去一个时间段后的日期。</p><p>expr是一个表达式，用来指定从起始日期添加或减去的时间间隔值。</p><p>expr是一个字符串。对于负值的时间间隔，它可以用一个负号“-”开头。</p><p>expr表达式与后面的间隔类型type对应。</p><p>MySQL中的日期间隔类型如下表所示：<br><img src="https://cdn.shieldofzues.cn/2020-07-31-load.jpg" class="lazyload" data-src="https://cdn.shieldofzues.cn/2020-06-02-060805.png"  alt=""></p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springspringboot必须知道的事</title>
      <link href="/2019/02/27/springspringboot%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%84%E4%BA%8B/"/>
      <url>/2019/02/27/springspringboot%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%84%E4%BA%8B/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.shieldofzues.cn/2020-07-31-load.jpg" class="lazyload" data-src="https://cdn.shieldofzues.cn/2020-09-15-042138.png"  alt=""></p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><p><img src="https://cdn.shieldofzues.cn/2020-07-31-load.jpg" class="lazyload" data-src="https://cdn.shieldofzues.cn/2020-09-15-917856-20160830090316402-526575145.jpg"  alt=""></p><p>Spring是一个开放源代码的设计层面框架，他解决的是业务逻辑层和其他各层的松耦合问题，因此它将面向接口的编程思想贯穿整个系统应用。可以接管web层，业务层，dao层，持久层的组件，并且可以配置各种bean,和维护bean与bean之间的关系。其核心就是控制反转(IOC),和面向切面(AOP) ，简单来说，Spring是一个分层的JavaSE/EE <strong>full-stack(一站式)</strong> 轻量级开源框架。</p><p>内部最核心的就是<strong>IOC</strong>了，动态注入，让一个对象的创建不用new了，可以自动的生产，这其实就是利用java里的反射，反射其实就是在运行时动态的去创建、调用对象，Spring就是在运行时，跟xml Spring的配置文件来动态的创建对象，和调用对象里的方法的 。<br>   Spring还有一个核心就是<strong>AOP</strong>这个就是面向切面编程，可以为某一类对象 进行监督和控制（也就是 在调用这类对象的具体方法的前后去调用你指定的 模块）从而达到对一个模块扩充的功能。这些都是通过 配置类达到的。<br>   <strong>Spring目的</strong>：就是让对象与对象（模块与模块）之间的关系没有通过代码来关联，都是通过配置类说明管理的（Spring根据这些配置 内部通过反射去动态的组装对象） </p><p><em>Spring是一个容器，凡是在容器里的对象才会有Spring所提供的这些服务和功能。</em> </p><h3 id="Spring-AOP与IOC"><a href="#Spring-AOP与IOC" class="headerlink" title="Spring AOP与IOC"></a><strong>Spring AOP与IOC</strong></h3><h4 id="一、-IoC-Inversion-of-control-控制反转"><a href="#一、-IoC-Inversion-of-control-控制反转" class="headerlink" title="一、 IoC(Inversion of control): 控制反转"></a><strong>一、 IoC(Inversion of control): 控制反转</strong></h4><p>1、IoC：<br>概念：控制权由对象本身转向容器；由容器根据配置文件去创建实例并创建各个实例之间的依赖关系<br>核心：bean工厂；在Spring中，bean工厂创建的各个实例称作bean </p><p>注入方式：</p><p>2.1 Set注入</p><p>2.2 构造器注入</p><p>2.3  静态工厂的方法注入</p><h4 id="二、AOP-Aspect-Oriented-Programming-面向方面编程"><a href="#二、AOP-Aspect-Oriented-Programming-面向方面编程" class="headerlink" title="二、AOP(Aspect-Oriented Programming): 面向方面编程"></a><strong>二、AOP(Aspect-Oriented Programming): 面向方面编程</strong></h4><p>1、 代理的两种方式：<br>静态代理：<br> 针对每个具体类分别编写代理类；<br> 针对一个接口编写一个代理类；<br>动态代理：<br>针对一个方面编写一个InvocationHandler，然后借用JDK反射包中的Proxy类为各种接口动态生成相应的代理类</p><h4 id="三、spring的核心接口及核类配置文件是什么"><a href="#三、spring的核心接口及核类配置文件是什么" class="headerlink" title="三、spring的核心接口及核类配置文件是什么?"></a>三、spring的核心接口及核类配置文件是什么?</h4><p> FactoryBean:工厂bean主要实现ioc/di</p><p>ApplicationContext ac=new FileXmlApplicationContext(“applicationContext.xml”);</p><p>Object obj=ac.getBean(“id值”);</p><h4 id="四、spring的7个核心模块"><a href="#四、spring的7个核心模块" class="headerlink" title="四、spring的7个核心模块"></a>四、spring的7个核心模块</h4><p>Spring 框架是一个分层架构，由 7 个定义良好的模块组成。Spring 模块构建在核心容器之上，核心容器定义了创建、配置和管理 bean 的方式，组成 Spring 框架的每个模块（或组件）都可以单独存在，或者与其他一个或多个模块联合实现。每个模块的功能如下：</p><p>   核心容器：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 BeanFactory，它是工厂模式的实现。BeanFactory 使用控制反转 （IOC）模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。</p><p>   Spring 上下文：Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。</p><p>   Spring AOP：通过配置管理特性，Spring AOP 模块直接将面向方面的编程功能集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理的任何对象支持 AOP。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖 EJB 组件，就可以将声明性事务管理集成到应用程序中。</p><p>   Spring DAO：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。</p><p>   Spring ORM：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。</p><p>   Spring Web 模块：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。</p><p>   Spring MVC 框架：MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。</p><p>Spring 框架的功能可以用在任何 J2EE 服务器中，大多数功能也适用于不受管理的环境。Spring 的核心要点是：支持不绑定到特定 J2EE 服务的可重用业务和数据访问对象。毫无疑问，这样的对象可以在不同 J2EE 环境 （Web 或 EJB）、独立应用程序、测试环境之间重用。</p><h2 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h2><p>Spring MVC属于SpringFrameWork的后续产品，已经融合在Spring Web Flow里面。Spring 框架提供了构建 Web 应用程序的全功能 MVC 模块。使用 Spring 可插入的 MVC 架构，可以选择是使用内置的 Spring Web 框架还可以是 Struts 这样的 Web 框架。专门用来开发SpringWeb项目的一种MVC模式的技术框架实现。其原理如下：</p><p><img src="https://cdn.shieldofzues.cn/2020-07-31-load.jpg" class="lazyload" data-src="https://cdn.shieldofzues.cn/2020-09-15-v2-070bf22c671ee0d12a747ce03b3b2208_1440w.jpg"  alt=""></p><p>Spring 框架提供了构建 Web 应用程序的全功能 MVC 模块。使用 Spring 可插入的 MVC 架构，可以选择是使用内置的 Spring Web 框架还是 Struts 这样的 Web 框架。通过策略接口，Spring 框架是高度可配置的，而且包含多种视图技术，例如 JavaServer Pages（JSP）技术、Velocity、Tiles、iText 和 POI。Spring MVC 框架并不知道使用的视图，所以不会强迫您只使用 JSP 技术。Spring MVC 分离了控制器、模型对象、分派器以及处理程序对象的角色，这种分离让它们更容易进行定制。</p><h2 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h2><p>Springboot是一个微服务框架，延续了spring框架的核心思想IOC和AOP，简化了应用的开发和部署。Spring Boot是为了简化Spring应用的创建、运行、调试、部署等而出现的，使用它可以做到专注于Spring应用的开发，而无需过多关注XML的配置。</p><p>​       通过Spring Boot，可以轻松地创建独立的，基于生产级别的基于Spring的应用程序，并且可以“运行”它们。</p><p>我们对Spring平台和第三方库持固执己见的观点，因此您可以以最小的麻烦开始使用。大多数Spring Boot应用程序需要最少的Spring配置。</p><p>特征：</p><ul><li>创建独立的Spring应用程序</li><li>直接嵌入Tomcat，Jetty或Undertow（无需部署WAR文件）</li><li>提供自以为是的“入门”依赖项，以简化构建配置</li><li>尽可能自动配置Spring和3rd Party库</li><li>提供可用于生产的功能，例如指标，运行状况检查和外部化配置</li><li>完全没有代码生成，也不需要XML配置</li></ul><p><a href="https://blog.csdn.net/zlc3323/article/details/100137222" target="_blank" rel="noopener">推荐阅读：springboot启动原理及源码解析</a></p><p>@SpringBootApplication注解是Spring Boot的核心注解，它其实是一个组合注解：</p><ul><li><p><strong>@Configuration</strong>（<em>@Configuration对我们来说不陌生，它就是JavaConfig形式的Spring Ioc容器的配置类使用的那个@Configuration，SpringBoot社区推荐使用基于JavaConfig的配置形式，所以，这里的启动类标注了@Configuration之后，本身其实也是一个IoC容器的配置类。</em>）</p></li><li><p><strong>@EnableAutoConfiguration</strong>（<em>借助@Import的支持，收集和注册特定场景相关的bean定义。</em></p><ul><li><em>@EnableScheduling是通过@Import将Spring调度框架相关的bean定义都加载到IoC容器。</em></li><li><em>@EnableMBeanExport是通过@Import将JMX相关的bean定义加载到IoC容器。</em></li></ul><p><em>而@EnableAutoConfiguration也是借助@Import的帮助，将所有符合自动配置条件的bean定义加载到IoC容器，仅此而已！</em></p><p>  <em>@EnableAutoConfiguration会根据类路径中的jar依赖为项目进行自动配置，如：添加了spring-boot-starter-web依赖，会自动添加Tomcat和Spring MVC的依赖，Spring Boot会对Tomcat和Spring MVC进行自动配置。</em>）</p></li><li><p><strong>@ComponentScan</strong>（<em>@ComponentScan这个注解在Spring中很重要，它对应XML配置中的元素，@ComponentScan的功能其实就是自动扫描并加载符合条件的组件（比如@Component和@Repository等）或者bean定义，最终将这些bean定义加载到IoC容器中。</em></p><p>   <em>我们可以通过basePackages等属性来细粒度的定制@ComponentScan自动扫描的范围，如果不指定，则默认Spring框架实现会从声明@ComponentScan所在类的package进行扫描。</em></p><p><em>注：所以SpringBoot的启动类最好是放在root package下，因为默认不指定basePackages。</em>）</p></li></ul><p>即 @SpringBootApplication = (默认属性)@Configuration + @EnableAutoConfiguration + @ComponentScan。</p><p>所以，如果我们使用如下的SpringBoot启动类，整个SpringBoot应用依然可以与之前的启动类功能对等。</p><h5 id="spring-boot自动装配原理："><a href="#spring-boot自动装配原理：" class="headerlink" title="spring boot自动装配原理："></a>spring boot自动装配原理：</h5><p>（1）引导类上开启@EnableAutoConfiguration<br>（2）内部通过@import注解引入ImporttSelector<br>（3）查找工程jar包中META-INF/spring.factories文件<br>（4）装载内部的对象到容器</p><h5 id="springboot的run方法执行流程如下："><a href="#springboot的run方法执行流程如下：" class="headerlink" title="springboot的run方法执行流程如下："></a>springboot的run方法执行流程如下：</h5><p>1） 如果我们使用的是SpringApplication的静态run方法，那么，这个方法里面首先要创建一个SpringApplication对象实例，然后调用这个创建好的SpringApplication的实例方法。在SpringApplication实例初始化的时候，它会提前做几件事情：<br>根据classpath里面是否存在某个特征类（org.springframework.web.context.ConfigurableWebApplicationContext）来决定是否应该创建一个为Web应用使用的ApplicationContext类型。<br>使用SpringFactoriesLoader在应用的classpath中查找并加载所有可用的ApplicationContextInitializer。<br>使用SpringFactoriesLoader在应用的classpath中查找并加载所有可用的ApplicationListener。</p><p>推断并设置main方法的定义类。</p><p>2） SpringApplication实例初始化完成并且完成设置后，就开始执行run方法的逻辑了，方法执行伊始，首先遍历执行所有通过SpringFactoriesLoader可以查找到并加载的SpringApplicationRunListener。调用它们的started()方法，告诉这些SpringApplicationRunListener，“嘿，SpringBoot应用要开始执行咯！”。</p><p>3） 创建并配置当前Spring Boot应用将要使用的Environment（包括配置要使用的PropertySource以及Profile）。</p><p>4） 遍历调用所有SpringApplicationRunListener的environmentPrepared()的方法，告诉他们：“当前SpringBoot应用使用的Environment准备好了咯！”。</p><p>5） 如果SpringApplication的showBanner属性被设置为true，则打印banner。</p><p>6） 根据用户是否明确设置了applicationContextClass类型以及初始化阶段的推断结果，决定该为当前SpringBoot应用创建什么类型的ApplicationContext并创建完成，然后根据条件决定是否添加ShutdownHook，决定是否使用自定义的BeanNameGenerator，决定是否使用自定义的ResourceLoader，当然，最重要的，将之前准备好的Environment设置给创建好的ApplicationContext使用。</p><p>7） ApplicationContext创建好之后，SpringApplication会再次借助Spring-FactoriesLoader，查找并加载classpath中所有可用的ApplicationContext-Initializer，然后遍历调用这些ApplicationContextInitializer的initialize（applicationContext）方法来对已经创建好的ApplicationContext进行进一步的处理。</p><p>8） 遍历调用所有SpringApplicationRunListener的contextPrepared()方法。</p><p>9） 最核心的一步，将之前通过@EnableAutoConfiguration获取的所有配置以及其他形式的IoC容器配置加载到已经准备完毕的ApplicationContext。</p><p>10） 遍历调用所有SpringApplicationRunListener的contextLoaded()方法。</p><p>11） 调用ApplicationContext的refresh()方法，完成IoC容器可用的最后一道工序。</p><p>12） 查找当前ApplicationContext中是否注册有CommandLineRunner，如果有，则遍历执行它们。</p><p>13） 正常情况下，遍历执行SpringApplicationRunListener的finished()方法、（如果整个过程出现异常，则依然调用所有SpringApplicationRunListener的finished()方法，只不过这种情况下会将异常信息一并传入处理）</p><p>去除事件通知点后，整个流程如下：</p><p><img src="https://cdn.shieldofzues.cn/2020-07-31-load.jpg" class="lazyload" data-src="https://cdn.shieldofzues.cn/2020-09-15-%E6%88%AA%E5%B1%8F2020-09-15%20%E4%B8%8B%E5%8D%881.41.43.png"  alt=""></p><h4 id="归纳"><a href="#归纳" class="headerlink" title="归纳"></a>归纳</h4><p>在部署环境中<code>Spring Boot</code> 对比<code>Spring</code>的一些优点包括：</p><ul><li>提供嵌入式容器支持</li><li>使用命令<em>java -jar</em>独立运行jar</li><li>在外部容器中部署时，可以选择排除依赖关系以避免潜在的jar冲突</li><li>部署时灵活指定配置文件的选项</li><li>用于集成测试的随机端口生成</li></ul><p>Spring包含了SpringMVC，而SpringBoot又包含了Spring或者说是在Spring的基础上做得一个扩展。</p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring、springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录 maven项目添加自定义jar包</title>
      <link href="/2019/02/18/maven%E8%87%AA%E5%AE%9A%E4%B9%89jar/"/>
      <url>/2019/02/18/maven%E8%87%AA%E5%AE%9A%E4%B9%89jar/</url>
      
        <content type="html"><![CDATA[<p>maven项目添加自定义jar包<br>1.确保在cmd当中可以正确使用mvn命令（通过mvn -v可以验证），然后使用如下命令：</p><p>mvn install:install-file -Dfile=包路径\xx.jar -DgroupId=com.yangjian.farme(可自定义) -DartifactId=jsper(可自定义) -Dversion=12.1(可自定义版本号) -Dpackaging=jar</p><p>说明：-Dfile参数指你自定义JAR包文件所在的路径，并依次指定了自定义的GroupId、ArtifactId和Version信息。<br>通过这种方式，可以简单快速地将第三方JAR包安装到本地仓库中供Maven项目依赖使用。例如：<br>2.添加项目依赖即可</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.yangjian.farme<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>12.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>idea 去除所有未引用的包（即如图：灰色的import）（附：官方帮助文档）</title>
      <link href="/2018/07/03/idea%E5%AF%BC%E5%8C%85/"/>
      <url>/2018/07/03/idea%E5%AF%BC%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.shieldofzues.cn/2020-07-31-load.jpg" class="lazyload" data-src="https://cdn.shieldofzues.cn/2020-06-02-055500.png"  alt="">jsp中的无用包;<br><img src="https://cdn.shieldofzues.cn/2020-07-31-load.jpg" class="lazyload" data-src="https://cdn.shieldofzues.cn/2020-06-02-055525.png"  alt="">类中的无用包;<br>方法一：包以上：均可以一并。去掉当前页面或类下直接快捷键Ctrl + Alt + O;<br>方法二：推荐设置如图，配置随时自动清除，勾选如下选项即可<img src="https://cdn.shieldofzues.cn/2020-07-31-load.jpg" class="lazyload" data-src="https://cdn.shieldofzues.cn/2020-06-02-055543.png"  alt=""><br>方法三：官方帮助文档（原理同上）：可用谷歌浏览器（或其他带有自动翻译功能的浏览器）查看，如果你英语足够好，可忽略前边的话。<br><a href="https://www.jetbrains.com/help/idea/creating-and-optimizing-imports.html#disable-import-popups" target="_blank" rel="noopener">https://www.jetbrains.com/help/idea/creating-and-optimizing-imports.html#disable-import-popups</a><br>对应idea版本可稍微注意，可能版本不同略有差异。<br>注意：此文档包含了idea使用的说明，可保存随时查看之需。希望帮到你~~</p>]]></content>
      
      
      <categories>
          
          <category> idea </category>
          
      </categories>
      
      
        <tags>
            
            <tag> idea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NIO网络编程原理</title>
      <link href="/2018/04/28/NIO%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%8E%9F%E7%90%86/"/>
      <url>/2018/04/28/NIO%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="IO：阻塞IO"><a href="#IO：阻塞IO" class="headerlink" title="IO：阻塞IO"></a>IO：阻塞IO</h2><h2 id="BIO：同步阻塞IO"><a href="#BIO：同步阻塞IO" class="headerlink" title="BIO：同步阻塞IO"></a>BIO：同步阻塞IO</h2><p>服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器需要启动一个线程进行处理，如果这个链接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。</p><h2 id="NIO：同步非阻塞IO"><a href="#NIO：同步非阻塞IO" class="headerlink" title="NIO：同步非阻塞IO"></a>NIO：同步非阻塞IO</h2><p>服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有IO请求时才启动一个线程进行处理。用户进程也需要时不时的询问IO操作是否就绪，这需要用户进行不停的去询问。NIO的包括三个核心概念:缓冲区(Buffer)、通道(Channel)、选择器(Selector)。</p><h2 id="AIO：Asynchronous-IO，异步非阻塞AIO"><a href="#AIO：Asynchronous-IO，异步非阻塞AIO" class="headerlink" title="AIO：Asynchronous IO，异步非阻塞AIO"></a>AIO：Asynchronous IO，异步非阻塞AIO</h2><p>最大的特性时具有异步能力，这种能力对socket与文件I/O都起作用。AIO其实是一种在读写操作结束之前允许进行其他操作的I/O处理。</p><h1 id="NIO与IO的区别"><a href="#NIO与IO的区别" class="headerlink" title="NIO与IO的区别"></a>NIO与IO的区别</h1><p>io是面向流且阻塞的；nio有选择器、面向缓冲区且非阻塞的；</p><p><img src="https://cdn.shieldofzues.cn/2020-07-31-load.jpg" class="lazyload" data-src="https://cdn.shieldofzues.cn/2020-09-15-%E6%88%AA%E5%B1%8F2020-09-15%20%E4%B8%8B%E5%8D%884.12.25.png"  alt=""></p><p>当n多个客户端接入进来后，服务端都在等待，造成网络瓶颈；</p><p><em>阻塞的意思就如：去网上下载一些东西，调用download方法，如果是阻塞的，整个线程都会堵在这个download方法里，直到结束，返回值（若网络延迟五秒就会堵在这五秒）；而非阻塞，同样的场景会立刻返回有结果还是无结果。</em></p><table><thead><tr><th></th><th>同步阻塞IO（VIO）</th><th>非阻塞IO（NIO）</th><th>异步IO（AIO）</th></tr></thead><tbody><tr><td>客户端个数：IO线程</td><td>1:1</td><td>M:1（1个IO线程处理多个客户端连接）</td><td>M:0（不需要启动额外的IO线程，被动回调）</td></tr><tr><td>IO类型（阻塞）</td><td>阻塞</td><td>非阻塞</td><td>非阻塞</td></tr><tr><td>IO类型（同步）</td><td>同步</td><td>同步</td><td>异步</td></tr><tr><td>API使用难度</td><td>简单</td><td>简单</td><td>复杂</td></tr><tr><td>调试难度</td><td>简单</td><td>简单</td><td>复杂</td></tr><tr><td>可靠性</td><td>非常差</td><td>差</td><td>高</td></tr><tr><td>吞吐量</td><td>低</td><td>中</td><td>高</td></tr></tbody></table><p><img src="https://cdn.shieldofzues.cn/2020-07-31-load.jpg" class="lazyload" data-src="https://cdn.shieldofzues.cn/2020-09-15-%E6%88%AA%E5%B1%8F2020-09-15%20%E4%B8%8B%E5%8D%884.15.26.png"  alt="">                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      </p><p>bio网络编程模型是阻塞式io模型；弹性伸缩能力差；多线程耗资源；而nio是非阻塞io;弹性伸缩能力较前者提升；单线程节省资源。</p><h1 id="NIO核心"><a href="#NIO核心" class="headerlink" title="NIO核心"></a>NIO核心</h1><p>Channel：通道</p><p>Buffer：缓冲区</p><p>Selector: 选择器、多路复用器</p><h2 id="NIO网络编程缺陷："><a href="#NIO网络编程缺陷：" class="headerlink" title="NIO网络编程缺陷："></a>NIO网络编程缺陷：</h2><p>NIO类库和API繁杂；</p><p>可靠性能力补齐、工作量和难度大；</p><p>Selector空轮询，cpu100%；</p><h1 id="NIO编程实现步骤"><a href="#NIO编程实现步骤" class="headerlink" title="NIO编程实现步骤"></a>NIO编程实现步骤</h1><p>1.创建Selector</p><p>2.创建ServerSocketChannel,创建Channel通道，并绑定监听端口</p><p>3.将Channel设置为非阻塞模式</p><p>4.将Channel注册到selector上，监听连接事件</p><p>5.循环调用Selector的select方法，检测就绪情况</p><p>6.调用selectorKeys方法，获取就绪channel集合</p><p>7.判断就绪事件种类，调用业务处理方法</p><p>8.根据业务需要决定是否再次注册监听事件，重复执行第3步操作</p><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>BIO：适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4之前的唯一选择， 但是程序简单直观容易理解。</p><p>NIO：适用于连接数目多且连接比较短（轻操作）的架构，比如聊推荐服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。（比如：实现一个多人聊天室功能）</p><p>AIO：适用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK1.7开始支持。</p>]]></content>
      
      
      <categories>
          
          <category> nio </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工作中常用docker命令</title>
      <link href="/2017/10/01/%E5%B7%A5%E4%BD%9C%E4%B8%AD%E5%B8%B8%E7%94%A8docker%E5%91%BD%E4%BB%A4/"/>
      <url>/2017/10/01/%E5%B7%A5%E4%BD%9C%E4%B8%AD%E5%B8%B8%E7%94%A8docker%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.shieldofzues.cn/2020-07-31-load.jpg" class="lazyload" data-src="https://cdn.shieldofzues.cn/2020-09-12-docker01.png"  alt=""></p><h1 id="查看docker镜像"><a href="#查看docker镜像" class="headerlink" title="查看docker镜像"></a>查看docker镜像</h1><p>docker images</p><p>查看的内容包含：镜像名称、镜像标签、镜像ID</p><h1 id="查看docker容器运行情况（包括已停止的容器）"><a href="#查看docker容器运行情况（包括已停止的容器）" class="headerlink" title="查看docker容器运行情况（包括已停止的容器）"></a>查看docker容器运行情况（包括已停止的容器）</h1><p>docker ps -a</p><p>查看的内容包含：容器ID、镜像名称、容器与宿主机映射的端口号、容器的名称</p><h1 id="启动docker"><a href="#启动docker" class="headerlink" title="启动docker"></a>启动docker</h1><p>docker start （restart）容器名称</p><p>或者 docker start 容器id;</p><p><strong>docker run ：</strong>创建一个新的容器并运行一个命令</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><p><strong>-a stdin:</strong> 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项；</p></li><li><p><strong>-d:</strong> 后台运行容器，并返回容器ID；</p></li><li><p><strong>-i:</strong> 以交互模式运行容器，通常与 -t 同时使用；</p></li><li><p><strong>-P:</strong> 随机端口映射，容器内部端口<strong>随机</strong>映射到主机的端口</p></li><li><p><strong>-p:</strong> 指定端口映射，格式为：<strong>主机(宿主)端口:容器端口</strong></p></li><li><p><strong>-t:</strong> 为容器重新分配一个伪输入终端，通常与 -i 同时使用；</p></li><li><p><strong>–name=”nginx-lb”:</strong> 为容器指定一个名称；</p></li><li><p><strong>–dns 8.8.8.8:</strong> 指定容器使用的DNS服务器，默认和宿主一致；</p></li><li><p><strong>–dns-search example.com:</strong> 指定容器DNS搜索域名，默认和宿主一致；</p></li><li><p><strong>-h “mars”:</strong> 指定容器的hostname；</p></li><li><p><strong>-e username=”ritchie”:</strong> 设置环境变量；</p></li><li><p><strong>–env-file=[]:</strong> 从指定文件读入环境变量；</p></li><li><p><strong>–cpuset=”0-2” or –cpuset=”0,1,2”:</strong> 绑定容器到指定CPU运行；</p></li><li><p><strong>-m :</strong>设置容器使用内存最大值；</p></li><li><p><strong>–net=”bridge”:</strong> 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型；</p></li><li><p><strong>–link=[]:</strong> 添加链接到另一个容器；</p></li><li><p><strong>–expose=[]:</strong> 开放一个端口或一组端口；</p></li><li><p><strong>–volume , -v:</strong> 绑定一个卷</p></li><li><p># docker run -it -v /test:/soft centos /bin/bash</p><p>这样在容器启动后，容器内会自动创建/soft的目录。-v参数中，冒号”:”前面的目录是宿主机目录，后面的目录是容器内目录(一般将配置如nginx、mysql的配置文件或数据目录挂载到宿主机目录下)。</p></li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>使用docker镜像nginx:latest以后台模式启动一个容器,并将容器命名为mynginx。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name mynginx -d nginx:latest</span><br></pre></td></tr></table></figure><p>使用镜像nginx:latest以后台模式启动一个容器,并将容器的80端口映射到主机随机端口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -P -d nginx:latest</span><br></pre></td></tr></table></figure><p>使用镜像 nginx:latest，以后台模式启动一个容器,将容器的 80 端口映射到主机的 80 端口,主机的目录 /data 映射到容器的 /data。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 80:80 -v &#x2F;data:&#x2F;data -d nginx:latest</span><br></pre></td></tr></table></figure><p>绑定容器的 8080 端口，并将其映射到本地主机 127.0.0.1 的 80 端口上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -p 127.0.0.1:80:8080&#x2F;tcp ubuntu bash</span><br></pre></td></tr></table></figure><p>使用镜像nginx:latest以交互模式启动一个容器,在容器内执行/bin/bash命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">runoob@runoob:~$ docker run -it nginx:latest &#x2F;bin&#x2F;bash</span><br><span class="line">root@b8573233d675:&#x2F;#</span><br></pre></td></tr></table></figure><h1 id="停止docker"><a href="#停止docker" class="headerlink" title="停止docker"></a>停止docker</h1><p>docker stop 容器名称或者 docker stop 容器id（前几位也可以）</p><h1 id="进入docker容器"><a href="#进入docker容器" class="headerlink" title="进入docker容器"></a>进入docker容器</h1><p>docker attach 容器ID</p><p>docker exec -it 容器ID /bin/bash </p><h1 id="退出容器到宿主机"><a href="#退出容器到宿主机" class="headerlink" title="退出容器到宿主机"></a>退出容器到宿主机</h1><p>exit或Ctrl+P+Q</p><h1 id="docker-cp-用于容器与主机之间的数据拷贝。"><a href="#docker-cp-用于容器与主机之间的数据拷贝。" class="headerlink" title="docker cp :**用于容器与主机之间的数据拷贝。"></a>docker cp :**用于容器与主机之间的数据拷贝。</h1><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|-</span><br><span class="line">docker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATH</span><br></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><strong>-L :</strong>保持源目标中的链接</li></ul><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>将主机/www/runoob目录拷贝到容器96f7f14e99ab的/www目录下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp &#x2F;www&#x2F;runoob 96f7f14e99ab:&#x2F;www&#x2F;</span><br></pre></td></tr></table></figure><p>将主机/www/runoob目录拷贝到容器96f7f14e99ab中，目录重命名为www。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp &#x2F;www&#x2F;runoob 96f7f14e99ab:&#x2F;www</span><br></pre></td></tr></table></figure><p>将容器96f7f14e99ab的/www目录拷贝到主机的/tmp目录中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp  96f7f14e99ab:&#x2F;www &#x2F;tmp&#x2F;</span><br></pre></td></tr></table></figure><h1 id="实时查看docker容器日志"><a href="#实时查看docker容器日志" class="headerlink" title="实时查看docker容器日志"></a>实时查看docker容器日志</h1><p>$ sudo docker logs -f -t –tail 行数 容器名（或容器ID）</p><p>例：实时查看docker容器名为mysql的最后10行日志</p><p>$ sudo docker logs -f -t –tail 10 mysql</p><h1 id="时区问题（之前开发遇到过的一个小问题）"><a href="#时区问题（之前开发遇到过的一个小问题）" class="headerlink" title="时区问题（之前开发遇到过的一个小问题）"></a>时区问题（之前开发遇到过的一个小问题）</h1><p>注意：数据库时区、docker容器时区（创建容器时和容器run时都可以指定）、服务器时区、还有时间格式化注解时区，如果后台返回给前端用了@JsonFormat(pattern = “yyyy-MM-dd HH:mm:ss”,timezone=”GMT+8”) 注意timezone；它们的一致性。</p>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机</title>
      <link href="/2016/05/06/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
      <url>/2016/05/06/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<p>推荐阅读：<img src="https://cdn.shieldofzues.cn/2020-07-31-load.jpg" class="lazyload" data-src="https://cdn.shieldofzues.cn/2020-09-13-%E6%88%AA%E5%B1%8F2020-09-13%20%E4%B8%8B%E5%8D%883.51.28.png"  alt="">)<a href="https://cdn.shieldofzues.cn/2020-09-13-深入理解jvm虚拟机.pdf" target="_blank" rel="noopener">点我:深入理解jvm虚拟机.pdf</a></p><h1 id="什么是jvm？"><a href="#什么是jvm？" class="headerlink" title="什么是jvm？"></a>什么是jvm？</h1><p>Java<a href="https://baike.baidu.com/item/虚拟机" target="_blank" rel="noopener">虚拟机</a>（Java Virtual Machine 简称JVM）是运行所有Java程序的抽象计算机，是<a href="https://baike.baidu.com/item/Java语言" target="_blank" rel="noopener">Java语言</a>的运行环境，它是Java 最具吸引力的特性之一。—百度百科</p><h1 id="Java内存区域与内存溢出异常"><a href="#Java内存区域与内存溢出异常" class="headerlink" title="Java内存区域与内存溢出异常"></a>Java内存区域与内存溢出异常</h1><p><img src="https://cdn.shieldofzues.cn/2020-07-31-load.jpg" class="lazyload" data-src="https://cdn.shieldofzues.cn/2020-09-15-aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvZGE3N2Q5MDE0Njc4NmMwY2IzZTE3MGI5YzkzNzZhZTQ_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ.webp"  alt=""></p><p>2.1.1 程序计数器</p><blockquote><p>内存空间小，线程私有。字节码解释器工作是就是通过改变这个计数器的值来选取下一条需要执行指令的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖计数器完成</p></blockquote><p>如果线程正在执行一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是 Native 方法，这个计数器的值则为 (Undefined)。此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。</p><p>2.1.2 Java 虚拟机栈</p><blockquote><p>线程私有，生命周期和线程一致。描述的是 Java 方法执行的内存模型：每个方法在执行时都会床创建一个栈帧(Stack Frame)用于存储<code>局部变量表</code>、<code>操作数栈</code>、<code>动态链接</code>、<code>方法出口</code>等信息。每一个方法从调用直至执行结束，就对应着一个栈帧从虚拟机栈中入栈到出栈的过程。</p></blockquote><p>局部变量表：存放了编译期可知的各种基本类型(boolean、byte、char、short、int、float、long、double)、对象引用(reference 类型)和 returnAddress 类型(指向了一条字节码指令的地址)</p><p>StackOverflowError：线程请求的栈深度大于虚拟机所允许的深度。<br>OutOfMemoryError：如果虚拟机栈可以动态扩展，而扩展时无法申请到足够的内存。</p><p>2.1.3 本地方法栈</p><blockquote><p>区别于 Java 虚拟机栈的是，Java 虚拟机栈为虚拟机执行 Java 方法(也就是字节码)服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。也会有 StackOverflowError 和 OutOfMemoryError 异常。</p></blockquote><p>2.1.4 Java 堆</p><blockquote><p>对于绝大多数应用来说，这块区域是 JVM 所管理的内存中最大的一块。线程共享，主要是存放对象实例和数组。内部会划分出多个线程私有的分配缓冲区(Thread Local Allocation Buffer, TLAB)。可以位于物理上不连续的空间，但是逻辑上要连续。</p></blockquote><p>OutOfMemoryError：如果堆中没有内存完成实例分配，并且堆也无法再扩展时，抛出该异常。</p><p>2.1.5 方法区</p><blockquote><p>属于共享内存区域，存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p></blockquote><p>2.1.6 运行时常量池</p><blockquote><p>属于方法区一部分，用于存放编译期生成的各种字面量和符号引用。编译器和运行期(String 的 intern() )都可以将常量放入池中。内存有限，无法申请时抛出 OutOfMemoryError。</p></blockquote><p>2.1.7 直接内存</p><blockquote><p>非虚拟机运行时数据区的部分</p></blockquote><p>在 JDK 1.4 中新加入 <a href="">NIO</a> (New Input/Output) 类，引入了一种基于通道(Channel)和缓存(Buffer)的 I/O 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。可以避免在 Java 堆和 Native 堆中来回的数据耗时操作。<br>OutOfMemoryError：会受到本机内存限制，如果内存区域总和大于物理内存限制从而导致动态扩展时出现该异常。</p><h1 id="hotspot虚拟机对象探秘（对象的创建、内存布局、及访问定位）"><a href="#hotspot虚拟机对象探秘（对象的创建、内存布局、及访问定位）" class="headerlink" title="hotspot虚拟机对象探秘（对象的创建、内存布局、及访问定位）"></a>hotspot虚拟机对象探秘（对象的创建、内存布局、及访问定位）</h1><p>通过以上java虚拟机的运行时数据区的学习后，我们了解了虚拟机内存概况及都存了些什么东西。那对象到底是怎样创建并使用的呢？</p><h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><p>《深入理解jvm虚拟机》第44页</p><p>通过 new 指令创建一个对象，首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有，执行相应的类加载。</p><p>类加载检查通过之后，为新对象分配内存(内存大小在类加载完成后便可确认)。在堆的空闲内存中划分一块区域(‘指针碰撞-内存规整’或‘空闲列表-内存交错’的分配方式)。</p><p>前面讲的每个线程在堆中都会有私有的分配缓冲区(TLAB)，这样可以很大程度避免在并发情况下频繁创建对象造成的线程不安全。</p><p>内存空间分配完成后会初始化为 0(不包括对象头)，接下来就是填充对象头，把对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息存入对象头。</p><p>执行 new 指令后执行 init 方法后才算一份真正可用的对象创建完成。</p><h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><blockquote><p>在 HotSpot 虚拟机中，分为 3 块区域：<code>对象头(Header)</code>、<code>实例数据(Instance Data)</code>和<code>对齐填充(Padding)</code></p></blockquote><p><code>对象头(Header)</code>：包含两部分，第一部分用于存储对象自身的运行时数据，如哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等，32 位虚拟机占 32 bit，64 位虚拟机占 64 bit。官方称为 ‘Mark Word’。第二部分是类型指针，即对象指向它的类的元数据指针，虚拟机通过这个指针确定这个对象是哪个类的实例。另外，如果是 Java 数组，对象头中还必须有一块用于记录数组长度的数据，因为普通对象可以通过 Java 对象元数据确定大小，而数组对象不可以。</p><p><code>实例数据(Instance Data)</code>：程序代码中所定义的各种类型的字段内容(包含父类继承下来的和子类中定义的)。</p><p><code>对齐填充(Padding)</code>：不是必然需要，主要是占位，保证对象大小是某个字节的整数倍。</p><h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><blockquote><p>使用对象时，通过栈上的 reference 数据来操作堆上的具体对象。</p></blockquote><p>通过句柄访问</p><blockquote><p>Java 堆中会分配一块内存作为句柄池。reference 存储的是句柄地址。详情见图。</p></blockquote><p><img src="https://cdn.shieldofzues.cn/2020-07-31-load.jpg" class="lazyload" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvZWJmMDBlZDI2YzM1YWVmZDkzZDVhM2EzNmIzYjE2MTM_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ"  alt="img"></p><p>使用直接指针访问</p><blockquote><p>reference 中直接存储对象地址</p></blockquote><p><img src="https://cdn.shieldofzues.cn/2020-07-31-load.jpg" class="lazyload" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvZGU2OTI0YjZlOWQ1NzYxMDViYTI0NzAwZjFmMzU3ZjQ_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ"  alt="img"></p><p>比较：使用句柄的最大好处是 reference 中存储的是稳定的句柄地址，在对象移动(GC)是只改变实例数据指针地址，reference 自身不需要修改。直接指针访问的最大好处是速度快，节省了一次指针定位的时间开销。如果是对象频繁 GC 那么句柄方法好，如果是对象频繁访问则直接指针访问好。</p><h1 id="实战：OutOfMemoryError-内存溢出-的三种情况及解决办法"><a href="#实战：OutOfMemoryError-内存溢出-的三种情况及解决办法" class="headerlink" title="实战：OutOfMemoryError(内存溢出)的三种情况及解决办法"></a>实战：OutOfMemoryError(内存溢出)的三种情况及解决办法</h1><p> jvm管理的内存大致包括三种不同类型的内存区域：Permanent Generation space（永久保存区域）、Heap space(堆区域)、Java Stacks(Java栈）。其中永久保存区域主要存放Class（类）和Meta的信息，Class第一次被Load的时候被放入PermGen space区域，Class需要存储的内容主要包括方法和静态属性。堆区域用来存放Class的实例（即对象），对象需要存储的内容主要是非静态属性。每次用new创建一个对象实例后，对象实例存储在堆区域中，这部分空间也被jvm的垃圾回收机制管理。而Java栈跟大多数编程语言包括汇编语言的栈功能相似，主要基本类型变量以及方法的输入输出参数。Java程序的每个线程中都有一个独立的堆栈。容易发生内存溢出问题的内存空间包括：Permanent Generation space和Heap space。</p><p>第一种OutOfMemoryError： PermGen space<br>发生这种问题的原意是程序中使用了大量的jar或class，使java虚拟机装载类的空间不够，与Permanent Generation space有关。解决这类问题有以下两种办法：<br>\1. 增加java虚拟机中的XX:PermSize和XX:MaxPermSize参数的大小，其中XX:PermSize是初始永久保存区域大小，XX:MaxPermSize是最大永久保存区域大小。如针对tomcat6.0，在catalina.sh 或catalina.bat文件中一系列环境变量名说明结束处（大约在70行左右） 增加一行：<br>JAVA_OPTS=” -XX:PermSize=64M -XX:MaxPermSize=128m”<br>如果是windows服务器还可以在系统环境变量中设置。感觉用tomcat发布sprint+struts+hibernate架构的程序时很容易发生这种内存溢出错误。使用上述方法，我成功解决了部署ssh项目的tomcat服务器经常宕机的问题。<br>\2. 清理应用程序中web-inf/lib下的jar，如果tomcat部署了多个应用，很多应用都使用了相同的jar，可以将共同的jar移到tomcat共同的lib下，减少类的重复加载。这种方法是网上部分人推荐的，我没试过，但感觉减少不了太大的空间，最靠谱的还是第一种方法。</p><p>第二种OutOfMemoryError：  Java heap space<br>发生这种问题的原因是java虚拟机创建的对象太多，在进行垃圾回收之间，虚拟机分配的到堆内存空间已经用满了，与Heap space有关。解决这类问题有两种思路：<br>\1. 检查程序，看是否有死循环或不必要地重复创建大量对象。找到原因后，修改程序和算法。<br>我以前写一个使用K-Means文本聚类算法对几万条文本记录（每条记录的特征向量大约10来个）进行文本聚类时，由于程序细节上有问题，就导致了Java heap space的内存溢出问题，后来通过修改程序得到了解决。<br>\2. 增加Java虚拟机中Xms（初始堆大小）和Xmx（最大堆大小）参数的大小。如：set JAVA_OPTS= -Xms256m -Xmx1024m</p><p>第三种OutOfMemoryError：unable to create new native thread<br>这种错误在Java线程个数很多的情况下容易发生。</p><p>参考：<a href="https://blog.csdn.net/u013521220/article/details/79523633" target="_blank" rel="noopener">内存溢出的解决方案</a></p><h1 id="垃圾回收器与内存分配策略"><a href="#垃圾回收器与内存分配策略" class="headerlink" title="垃圾回收器与内存分配策略"></a>垃圾回收器与内存分配策略</h1><blockquote><p>程序计数器、虚拟机栈、本地方法栈 3 个区域随线程生灭(因为是线程私有)，栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。而 Java 堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期才知道那些对象会创建，这部分内存的分配和回收都是动态的，垃圾回收期所关注的就是这部分内存。</p></blockquote><p>2.2.1 引用计数法</p><blockquote><p>给对象添加一个引用计数器。但是难以解决循环引用问题。</p></blockquote><p><img src="https://cdn.shieldofzues.cn/2020-07-31-load.jpg" class="lazyload" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvNGMyODlhMjI0Y2I0OTQ0ZTQ5OWZiNWJmZDMzZTU5MmY_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ"  alt="img"></p><p>从图中可以看出，如果不下小心直接把 Obj1-reference 和 Obj2-reference 置 null。则在 Java 堆当中的两块内存依然保持着互相引用无法回收。</p><p>2.2.2 可达性分析法</p><blockquote><p>通过一系列的 ‘GC Roots’ 的对象作为起始点，从这些节点出发所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连的时候说明对象不可用。</p></blockquote><p><img src="https://cdn.shieldofzues.cn/2020-07-31-load.jpg" class="lazyload" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvNThiZmFjMTVjYTZkMzA3NmRlZjUxNzRlZDVjYTVhOTk_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ"  alt="img"></p><p>可作为 GC Roots 的对象：</p><ul><li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中 JNI(即一般说的 Native 方法) 引用的对象</li></ul><p>2.2.3 再谈引用</p><blockquote><p>前面的两种方式判断存活时都与‘引用’有关。但是 JDK 1.2 之后，引用概念进行了扩充，下面具体介绍。</p></blockquote><p>下面四种引用强度一次逐渐减弱</p><p>强引用</p><blockquote><p>类似于 <code>Object obj = new Object();</code> 创建的，只要强引用在就不回收。</p></blockquote><p>软引用</p><blockquote><p>SoftReference 类实现软引用。在系统要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行二次回收。</p></blockquote><p>弱引用</p><blockquote><p>WeakReference 类实现弱引用。对象只能生存到下一次垃圾收集之前。在垃圾收集器工作时，无论内存是否足够都会回收掉只被弱引用关联的对象。</p></blockquote><p>虚引用</p><blockquote><p>PhantomReference 类实现虚引用。无法通过虚引用获取一个对象的实例，为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</p></blockquote><p>2.2.4 生存还是死亡</p><blockquote><p>即使在可达性分析算法中不可达的对象，也并非是“facebook”的，这时候它们暂时出于“缓刑”阶段，一个对象的真正死亡至少要经历两次标记过程：如果对象在进行中可达性分析后发现没有与 GC Roots 相连接的引用链，那他将会被第一次标记并且进行一次筛选，筛选条件是此对象是否有必要执行 finalize() 方法。当对象没有覆盖 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。</p><p>如果这个对象被判定为有必要执行 finalize() 方法，那么这个对象竟会放置在一个叫做 F-Queue 的队列中，并在稍后由一个由虚拟机自动建立的、低优先级的 Finalizer 线程去执行它。这里所谓的“执行”是指虚拟机会出发这个方法，并不承诺或等待他运行结束。finalize() 方法是对象逃脱死亡命运的最后一次机会，稍后 GC 将对 F-Queue 中的对象进行第二次小规模的标记，如果对象要在 finalize() 中成功拯救自己 —— 只要重新与引用链上的任何一个对象简历关联即可。</p><p>finalize() 方法只会被系统自动调用一次。</p></blockquote><p>2.2.5 回收方法区</p><blockquote><p>在堆中，尤其是在新生代中，一次垃圾回收一般可以回收 70% ~ 95% 的空间，而永久代的垃圾收集效率远低于此。</p><p>永久代垃圾回收主要两部分内容：废弃的常量和无用的类。</p></blockquote><p>判断废弃常量：一般是判断没有该常量的引用。</p><p>判断无用的类：要以下三个条件都满足</p><ul><li>该类所有的实例都已经回收，也就是 Java 堆中不存在该类的任何实例</li><li>加载该类的 ClassLoader 已经被回收</li><li>该类对应的 java.lang.Class 对象没有任何地方呗引用，无法在任何地方通过反射访问该类的方法</li></ul><h3 id="2-3-垃圾回收算法"><a href="#2-3-垃圾回收算法" class="headerlink" title="2.3 垃圾回收算法"></a>2.3 垃圾回收算法</h3><p>2.3.1 标记 —— 清除算法</p><blockquote><p>直接标记清除就可。</p></blockquote><p>两个不足：</p><ul><li>效率不高</li><li>空间会产生大量碎片</li></ul><p>2.3.2 复制算法</p><blockquote><p>把空间分成两块，每次只对其中一块进行 GC。当这块内存使用完时，就将还存活的对象复制到另一块上面。</p></blockquote><p>解决前一种方法的不足，但是会造成空间利用率低下。因为大多数新生代对象都不会熬过第一次 GC。所以没必要 1 : 1 划分空间。可以分一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 空间和其中一块 Survivor。当回收时，将 Eden 和 Survivor 中还存活的对象一次性复制到另一块 Survivor 上，最后清理 Eden 和 Survivor 空间。大小比例一般是 8 : 1 : 1，每次浪费 10% 的 Survivor 空间。但是这里有一个问题就是如果存活的大于 10% 怎么办？这里采用一种分配担保策略：多出来的对象直接进入老年代。</p><p>2.3.3 标记-整理算法</p><blockquote><p>不同于针对新生代的复制算法，针对老年代的特点，创建该算法。主要是把存活对象移到内存的一端。</p></blockquote><p>2.3.4 分代回收</p><blockquote><p>根据存活对象划分几块内存区，一般是分为新生代和老年代。然后根据各个年代的特点制定相应的回收算法。</p></blockquote><p>新生代</p><blockquote><p>每次垃圾回收都有大量对象死去，只有少量存活，选用复制算法比较合理。</p></blockquote><p>老年代</p><blockquote><p>老年代中对象存活率较高、没有额外的空间分配对它进行担保。所以必须使用 <code>标记 —— 清除</code> 或者 <code>标记 —— 整理</code> 算法回收。</p></blockquote><h3 id="2-4-HotSpot-的算法实现"><a href="#2-4-HotSpot-的算法实现" class="headerlink" title="2.4 HotSpot 的算法实现"></a>2.4 HotSpot 的算法实现</h3><h3 id="2-5-垃圾回收器"><a href="#2-5-垃圾回收器" class="headerlink" title="2.5 垃圾回收器"></a>2.5 垃圾回收器</h3><blockquote><p>收集算法是内存回收的理论，而垃圾回收器是内存回收的实践。</p></blockquote><p><img src="https://cdn.shieldofzues.cn/2020-07-31-load.jpg" class="lazyload" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvMTVmYjc1NDc2MmZmNWRmM2Y3ZjYzZTVjMjZkNGQzYWU_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ"  alt="img"></p><p>说明：如果两个收集器之间存在连线说明他们之间可以搭配使用。</p><p>2.5.1 Serial 收集器</p><blockquote><p>这是一个单线程收集器。意味着它只会使用一个 CPU 或一条收集线程去完成收集工作，并且在进行垃圾回收时必须暂停其它所有的工作线程直到收集结束。</p></blockquote><p><img src="https://cdn.shieldofzues.cn/2020-07-31-load.jpg" class="lazyload" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvYjE4NDk0YjFlNTQ4NTFiYmJkMmVlNTI3NjBjYzM3NTQ_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ"  alt="img"></p><p>2.5.2 ParNew 收集器</p><blockquote><p>可以认为是 Serial 收集器的多线程版本。</p></blockquote><p><img src="https://cdn.shieldofzues.cn/2020-07-31-load.jpg" class="lazyload" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvMTU0NjVmYjJlMTdjYjVkNjY1YzI1YmI5OGFjZmVhOTM_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ"  alt="img"></p><p>并行：Parallel</p><blockquote><p>指多条垃圾收集线程并行工作，此时用户线程处于等待状态</p></blockquote><p>并发：Concurrent</p><blockquote><p>指用户线程和垃圾回收线程同时执行(不一定是并行，有可能是交叉执行)，用户进程在运行，而垃圾回收线程在另一个 CPU 上运行。</p></blockquote><p>2.5.3 Parallel Scavenge 收集器</p><blockquote><p>这是一个新生代收集器，也是使用复制算法实现，同时也是并行的多线程收集器。</p></blockquote><p>CMS 等收集器的关注点是尽可能地缩短垃圾收集时用户线程所停顿的时间，而 Parallel Scavenge 收集器的目的是达到一个可控制的吞吐量(Throughput = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间))。</p><p>作为一个吞吐量优先的收集器，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整停顿时间。这就是 GC 的自适应调整策略(GC Ergonomics)。</p><p>2.5.4 Serial Old 收集器</p><blockquote><p>收集器的老年代版本，单线程，使用 <code>标记 —— 整理</code>。</p></blockquote><p><img src="https://cdn.shieldofzues.cn/2020-07-31-load.jpg" class="lazyload" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvYjE4NDk0YjFlNTQ4NTFiYmJkMmVlNTI3NjBjYzM3NTQ_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ"  alt="img"></p><p>2.5.5 Parallel Old 收集器</p><blockquote><p>Parallel Old 是 Parallel Scavenge 收集器的老年代版本。多线程，使用 <code>标记 —— 整理</code></p></blockquote><p><img src="https://cdn.shieldofzues.cn/2020-07-31-load.jpg" class="lazyload" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvMjU2NDEzNjZiNDNkOTcxMzEwYTBhN2NlZGU0ZTQwNmE_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ"  alt="img"></p><p>2.5.6 CMS 收集器</p><blockquote><p>CMS (Concurrent Mark Sweep) 收集器是一种以获取最短回收停顿时间为目标的收集器。基于 <code>标记 —— 清除</code> 算法实现。</p></blockquote><p>运作步骤:</p><ol><li>初始标记(CMS initial mark)：标记 GC Roots 能直接关联到的对象</li><li>并发标记(CMS concurrent mark)：进行 GC Roots Tracing</li><li>重新标记(CMS remark)：修正并发标记期间的变动部分</li><li>并发清除(CMS concurrent sweep)</li></ol><p><img src="https://cdn.shieldofzues.cn/2020-07-31-load.jpg" class="lazyload" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvNmY0ZDY4MzY0NGExNTQ1MzdiM2UyM2Q2MGQ0OWMwNzQ_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ"  alt="img"></p><p>缺点：对 CPU 资源敏感、无法收集浮动垃圾、<code>标记 —— 清除</code> 算法带来的空间碎片</p><p>2.5.7 G1 收集器</p><blockquote><p>面向服务端的垃圾回收器。</p></blockquote><p>优点：并行与并发、分代收集、空间整合、可预测停顿。</p><p>运作步骤:</p><ol><li>初始标记(Initial Marking)</li><li>并发标记(Concurrent Marking)</li><li>最终标记(Final Marking)</li><li>筛选回收(Live Data Counting and Evacuation)</li></ol><p><img src="https://cdn.shieldofzues.cn/2020-07-31-load.jpg" class="lazyload" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvNDBhNTc1OTMxYjI1NGE4ZjQwYmI1NDNjMjRlOGZhZGY_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ"  alt="img"></p><h3 id="2-6-内存分配与回收策略"><a href="#2-6-内存分配与回收策略" class="headerlink" title="2.6 内存分配与回收策略"></a>2.6 内存分配与回收策略</h3><p>2.6.1 对象优先在 Eden 分配</p><blockquote><p>对象主要分配在新生代的 Eden 区上，如果启动了本地线程分配缓冲区，将线程优先在 (TLAB) 上分配。少数情况会直接分配在老年代中。</p></blockquote><p>一般来说 Java 堆的内存模型如下图所示：</p><p><img src="https://cdn.shieldofzues.cn/2020-07-31-load.jpg" class="lazyload" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvOTcxMDE4MDMxNWQzNTc1NmI2OGU5YzVkYWY0NGQ2ZTU_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ"  alt="img"></p><p>新生代 GC (Minor GC)</p><blockquote><p>发生在新生代的垃圾回收动作，频繁，速度快。</p></blockquote><p>老年代 GC (Major GC / Full GC)</p><blockquote><p>发生在老年代的垃圾回收动作，出现了 Major GC 经常会伴随至少一次 Minor GC(非绝对)。Major GC 的速度一般会比 Minor GC 慢十倍以上。</p></blockquote><p>2.6.2 大对象直接进入老年代</p><p>2.6.3 长期存活的对象将进入老年代</p><p>2.6.4 动态对象年龄判定</p><p>2.6.5 空间分配担保</p><h1 id="Java-内存模型与线程"><a href="#Java-内存模型与线程" class="headerlink" title="Java 内存模型与线程"></a>Java 内存模型与线程</h1><p><img src="https://cdn.shieldofzues.cn/2020-07-31-load.jpg" class="lazyload" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvMjBhOTk2ODc0NmFmYTJhZmRlNGIzNzE2YmFiZjU1Y2U_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ"  alt="img"></p><h3 id="3-1-Java-内存模型"><a href="#3-1-Java-内存模型" class="headerlink" title="3.1 Java 内存模型"></a>3.1 Java 内存模型</h3><blockquote><p>屏蔽掉各种硬件和操作系统的内存访问差异。</p></blockquote><p><img src="https://cdn.shieldofzues.cn/2020-07-31-load.jpg" class="lazyload" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvOGY5ODMzMGRjOGFmNGNlOGNmNTM5N2EwMTMzMDhlYzI_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ"  alt="img"></p><p>3.1.1 主内存和工作内存之间的交互</p><table><thead><tr><th align="left">操作</th><th align="left">作用对象</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left">lock</td><td align="left">主内存</td><td align="left">把一个变量标识为一条线程独占的状态</td></tr><tr><td align="left">unlock</td><td align="left">主内存</td><td align="left">把一个处于锁定状态的变量释放出来，释放后才可被其他线程锁定</td></tr><tr><td align="left">read</td><td align="left">主内存</td><td align="left">把一个变量的值从主内存传输到线程工作内存中，以便 load 操作使用</td></tr><tr><td align="left">load</td><td align="left">工作内存</td><td align="left">把 read 操作从主内存中得到的变量值放入工作内存中</td></tr><tr><td align="left">use</td><td align="left">工作内存</td><td align="left">把工作内存中一个变量的值传递给执行引擎， 每当虚拟机遇到一个需要使用到变量值的字节码指令时将会执行这个操作</td></tr><tr><td align="left">assign</td><td align="left">工作内存</td><td align="left">把一个从执行引擎接收到的值赋接收到的值赋给工作内存的变量， 每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作</td></tr><tr><td align="left">store</td><td align="left">工作内存</td><td align="left">把工作内存中的一个变量的值传送到主内存中，以便 write 操作</td></tr><tr><td align="left">write</td><td align="left">工作内存</td><td align="left">把 store 操作从工作内存中得到的变量的值放入主内存的变量中</td></tr></tbody></table><p>3.1.2 对于 volatile 型变量的特殊规则</p><blockquote><p>关键字 volatile 是 Java 虚拟机提供的最轻量级的同步机制。</p></blockquote><p>一个变量被定义为 volatile 的特性：</p><ol><li>保证此变量对所有线程的可见性。但是操作并非原子操作，并发情况下不安全。</li></ol><blockquote><p>如果不符合 <code>运算结果并不依赖变量当前值，或者能够确保只有单一的线程修改变量的值</code> 和 <code>变量不需要与其他的状态变量共同参与不变约束</code> 就要通过加锁(使用 synchronize 或 java.util.concurrent 中的原子类)来保证原子性。</p></blockquote><ol><li>禁止指令重排序优化。</li></ol><blockquote><p>通过插入内存屏障保证一致性。</p></blockquote><p>3.1.3 对于 long 和 double 型变量的特殊规则</p><blockquote><p>Java 要求对于主内存和工作内存之间的八个操作都是原子性的，但是对于 64 位的数据类型，有一条宽松的规定：允许虚拟机将没有被 volatile 修饰的 64 位数据的读写操作划分为两次 32 位的操作来进行，即允许虚拟机实现选择可以不保证 64 位数据类型的 load、store、read 和 write 这 4 个操作的原子性。这就是 long 和 double 的非原子性协定。</p></blockquote><p>3.1.4 原子性、可见性与有序性</p><blockquote><p>回顾下并发下应该注意操作的那些特性是什么，同时加深理解。</p></blockquote><ul><li>原子性(Atomicity)</li></ul><blockquote><p>由 Java 内存模型来直接保证的原子性变量操作包括 read、load、assign、use、store 和 write。大致可以认为基本数据类型的操作是原子性的。同时 lock 和 unlock 可以保证更大范围操作的原子性。而 synchronize 同步块操作的原子性是用更高层次的字节码指令 monitorenter 和 monitorexit 来隐式操作的。</p></blockquote><ul><li>可见性(Visibility)</li></ul><blockquote><p>是指当一个线程修改了共享变量的值，其他线程也能够立即得知这个通知。主要操作细节就是修改值后将值同步至主内存(volatile 值使用前都会从主内存刷新)，除了 volatile 还有 synchronize 和 final 可以保证可见性。同步块的可见性是由“对一个变量执行 unlock 操作之前，必须先把此变量同步会主内存中( store、write 操作)”这条规则获得。而 final 可见性是指：被 final 修饰的字段在构造器中一旦完成，并且构造器没有把 “this” 的引用传递出去( this 引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象)，那在其他线程中就能看见 final 字段的值。</p></blockquote><ul><li>有序性(Ordering)</li></ul><blockquote><p>如果在被线程内观察，所有操作都是有序的；如果在一个线程中观察另一个线程，所有操作都是无序的。前半句指“线程内表现为串行的语义”，后半句是指“指令重排”现象和“工作内存与主内存同步延迟”现象。Java 语言通过 volatile 和 synchronize 两个关键字来保证线程之间操作的有序性。volatile 自身就禁止指令重排，而 synchronize 则是由“一个变量在同一时刻指允许一条线程对其进行 lock 操作”这条规则获得，这条规则决定了持有同一个锁的两个同步块只能串行的进入。</p></blockquote><p>3.1.5 先行发生原则</p><blockquote><p>也就是 happens-before 原则。这个原则是判断数据是否存在竞争、线程是否安全的主要依据。先行发生是 Java 内存模型中定义的两项操作之间的偏序关系。</p></blockquote><p>天然的先行发生关系</p><table><thead><tr><th align="left">规则</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left">程序次序规则</td><td align="left">在一个线程内，代码按照书写的控制流顺序执行</td></tr><tr><td align="left">管程锁定规则</td><td align="left">一个 unlock 操作先行发生于后面对同一个锁的 lock 操作</td></tr><tr><td align="left">volatile 变量规则</td><td align="left">volatile 变量的写操作先行发生于后面对这个变量的读操作</td></tr><tr><td align="left">线程启动规则</td><td align="left">Thread 对象的 start() 方法先行发生于此线程的每一个动作</td></tr><tr><td align="left">线程终止规则</td><td align="left">线程中所有的操作都先行发生于对此线程的终止检测 (通过 Thread.join() 方法结束、 Thread.isAlive() 的返回值检测)</td></tr><tr><td align="left">线程中断规则</td><td align="left">对线程 interrupt() 方法调用优先发生于被中断线程的代码检测到中断事件的发生 (通过 Thread.interrupted() 方法检测)</td></tr><tr><td align="left">对象终结规则</td><td align="left">一个对象的初始化完成(构造函数执行结束)先行发生于它的 finalize() 方法的开始</td></tr><tr><td align="left">传递性</td><td align="left">如果操作 A 先于 操作 B 发生，操作 B 先于 操作 C 发生，那么操作 A 先于 操作 C</td></tr></tbody></table><h3 id="3-2-Java-与线程"><a href="#3-2-Java-与线程" class="headerlink" title="3.2 Java 与线程"></a>3.2 Java 与线程</h3><p>3.2.1 线程的实现</p><p>使用内核线程实现</p><blockquote><p>直接由操作系统内核支持的线程，这种线程由内核完成切换。程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口 —— 轻量级进程(LWP)，轻量级进程就是我们通常意义上所讲的线程，每个轻量级进程都有一个内核级线程支持。</p></blockquote><p><img src="https://cdn.shieldofzues.cn/2020-07-31-load.jpg" class="lazyload" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvNGMwYTk1OTQ1ZTdjN2E1MmVmNmNjYmE0YWJiNzNkNDM_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ"  alt="img"></p><p>使用用户线程实现</p><blockquote><p>广义上来说，只要不是内核线程就可以认为是用户线程，因此可以认为轻量级进程也属于用户线程。狭义上说是完全建立在用户空间的线程库上的并且内核系统不可感知的。</p></blockquote><p><img src="https://cdn.shieldofzues.cn/2020-07-31-load.jpg" class="lazyload" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvZDE1YjY5NDgyNTIyMTAxMDRkOWNjY2YxODJkYjU4MjU_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ"  alt="img"></p><p>使用用户线程夹加轻量级进程混合实现</p><blockquote><p>直接看图</p></blockquote><p><img src="https://cdn.shieldofzues.cn/2020-07-31-load.jpg" class="lazyload" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvZjE2MmMwYmUwMGU0NzI5NTIyZmNlNDhkMjA5ODk5MTM_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ"  alt="img"></p><p><strong>Java 线程实现</strong></p><blockquote><p>平台不同实现方式不同，可以认为是一条 Java 线程映射到一条轻量级进程。</p></blockquote><p>3.2.2 Java 线程调度</p><p>协同式线程调度</p><blockquote><p>线程执行时间由线程自身控制，实现简单，切换线程自己可知，所以基本没有线程同步问题。坏处是执行时间不可控，容易阻塞。</p></blockquote><p>抢占式线程调度</p><blockquote><p>每个线程由系统来分配执行时间。</p></blockquote><p>3.2.3 状态转换</p><p>五种状态：</p><ul><li>新建(new)</li></ul><blockquote><p>创建后尚未启动的线程。</p></blockquote><ul><li>运行(Runable)</li></ul><blockquote><p>Runable 包括了操作系统线程状态中的 Running 和 Ready，也就是出于此状态的线程有可能正在执行，也有可能正在等待 CPU 为他分配时间。</p></blockquote><ul><li>无限期等待(Waiting)</li></ul><blockquote><p>出于这种状态的线程不会被 CPU 分配时间，它们要等其他线程显示的唤醒。</p></blockquote><p>以下方法会然线程进入无限期等待状态：<br>1.没有设置 Timeout 参数的 Object.wait() 方法。<br>2.没有设置 Timeout 参数的 Thread.join() 方法。<br>3.LookSupport.park() 方法。</p><ul><li>限期等待(Timed Waiting)</li></ul><blockquote><p>处于这种状态的线程也不会分配时间，不过无需等待配其他线程显示地唤醒，在一定时间后他们会由系统自动唤醒。</p></blockquote><p>以下方法会让线程进入限期等待状态：<br>1.Thread.sleep() 方法。<br>2.设置了 Timeout 参数的 Object.wait() 方法。<br>3.设置了 Timeout 参数的 Thread.join() 方法。<br>4.LockSupport.parkNanos() 方法。<br>5.LockSupport.parkUntil() 方法。</p><ul><li>阻塞(Blocked)</li></ul><blockquote><p>线程被阻塞了，“阻塞状态”和“等待状态”的区别是：“阻塞状态”在等待着获取一个排他锁，这个时间将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。</p></blockquote><ul><li>结束(Terminated)</li></ul><blockquote><p>已终止线程的线程状态。</p></blockquote><p><img src="https://cdn.shieldofzues.cn/2020-07-31-load.jpg" class="lazyload" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvNmFmOGVlNThhNTU0YWYzMmFjOTI0NGQ2NDY5MjFiYzc_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ"  alt="img"></p><h1 id="线程安全与锁优化"><a href="#线程安全与锁优化" class="headerlink" title="线程安全与锁优化"></a>线程安全与锁优化</h1><blockquote><p>1、概述</p><p>2、线程安全</p><p>2.1、Java语言中的线程安全</p><p>按照线程安全的“安全程度”由强至弱来排序，我们可以将Java语言中各种操作共享的数据分为以下5类：不可变、绝对线程安全、相对线程安全、线程建荣和线程对立。</p><p>不可变</p><p>不可变的对象一定是线程安全的。</p><p>保证对象行为不影响自己状态的途径有很多种，其中最简单的就是把对象中带有状态的变量都声明为final。</p><p>Java API中符合不可变要求的类型：String，java.lang.Number的部分子类（如Long和Double的数值包装类，BigInteger和BigDecimal等大数据类型但<code>AtomicInteger</code>和<code>AtomicLong</code>则并非不可变的）。</p><p>绝对线程安全</p><p>Java API中标注自己是线程安全的类，大多数都不是绝对线程安全的。</p><p>相对线程安全</p><p>Java语言中，大部分的线程安全都属于这种类型，例如Vector，HashTable，Collections的synchronizedCollection()方法包装的集合等。</p><p>线程兼容</p><p>指通过使用同步手段来保证对象在并发环境中可以安全的使用。Java API中大部分的类都是属于线程兼容的，如ArrayList和HashMap。</p><p>线程对立</p><p>指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。</p><p>一个线程对立的例子就是Thread类的suspend()和resumn()方法（已被JDK声明废弃了）。</p><p>常见的线程对立操作还有System.setIn(), System.setOut(), System.runFinalizersOnExit()…</p><p>2.2、线程安全的实现方法</p><p>互斥同步</p><p>Java中，最基本的互斥同步手段就是synchronized关键字。</p><p>synchronized是一个重量级的操作，因为：Java的线程是映射到操作系统的原生线程之上的，如果要阻塞或唤醒一个线程，都需要操作系统来帮忙完成，这就需要从用户态转换到核心态中，因此状态转换需要消耗很多的处理器时间。对于代码简单的同步块（如synchronized修饰的getter()和setter方法），状态转换消耗的时间有可能比用户代码执行的时间还要长。</p><p>还可以使用java.util.concurrent包中的<code>ReentrantLock(重入锁)</code>来实现同步：JDK1.5多线程环境下synchronized的吞吐量下降的很严重，而ReentrantLock则基本保持在同一个比较稳定的水平上。JDK 1.6之后两者性能基本持平。</p><p>虚拟机在未来的性能改进中还会更偏向于原生的synchronize的，所以还是</p><p>提倡在synchronized能实现需求的情况下，优先考虑使用synchronized来进行同步。</p><p>非阻塞同步</p><p>非阻塞同步：从处理问题的方式上说，互斥同步属于一种悲观的并发策略。随着硬件指令集的发展，我们可以采用基于冲突检查的乐观并发策略，通俗地说，就是先行操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生了冲突，那就再采取其他的补偿措施（最常见的补偿措施就是不断地重试，直到成功为止），这种乐观的并发策略的许多实现偶读不需要把线程挂起，因此这话总同步操作称为非阻塞同步。</p><p>无同步方案</p><p>如果一个方法本来就不设计共享数据，那它自然就无须任何同步措施去保证正确性，因此会有一些代码天生就是线程安全的。这类代码包括：可重入代码和线程本地存储。</p><p>3、锁优化</p><p>为了进一步改进高效并发，HotSpot虚拟机开发团队在JDK1.6版本上花费了大量精力实现各种锁优化。</p><p>##3.1、自旋锁与自适应自旋</p><p>为了让线程等待，我们只需要让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。引入自旋锁的原因是互斥同步对性能最大的影响是阻塞的实现，管钱线程和恢复线程的操作都需要转入内核态中完成，给并发带来很大压力。自旋锁让物理机器有一个以上的处理器的时候，能让两个或以上的线程同时并行执行。</p><p>3.2、锁消除</p><p>消除锁是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。</p><p>3.3、锁粗化</p><p>如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，则可以进行锁粗化的优化。</p><p>3.4、轻量级锁</p><p>它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。</p><p>但是如果存在锁竞争，除了互斥量的开销，还发生了CAS操作，因此在有竞争的情况下，轻量级锁会比传统的重量级锁更慢。</p><p>3.5、偏向锁</p><p>如果说轻量级锁是在无竞争的情况下使用了CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉了，连CAS操作都不做了。</p></blockquote><h1 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h1><p><a href="https://link.juejin.im/?target=https%3A%2F%2Fdocs.oracle.com%2Fjavase%2Fspecs%2Fjvms%2Fse7%2Fhtml%2Fjvms-4.html">1. Official：The class File Format</a><br><a href="https://link.juejin.im/?target=http%3A%2F%2Fblog.csdn.net%2Fluanlouis%2Farticle%2Fdetails%2F39892027">2.亦山: 《Java虚拟机原理图解》 1.1、class文件基本组织结构</a></p><h1 id="虚拟机类加载机制"><a href="#虚拟机类加载机制" class="headerlink" title="虚拟机类加载机制"></a>虚拟机类加载机制</h1><blockquote><p>虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、装换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型。</p></blockquote><p>在 Java 语言中，类型的加载、连接和初始化过程都是在程序运行期间完成的。</p><h3 id="6-1-类加载时机"><a href="#6-1-类加载时机" class="headerlink" title="6.1 类加载时机"></a>6.1 类加载时机</h3><p>类的生命周期( 7 个阶段)</p><p><img src="https://cdn.shieldofzues.cn/2020-07-31-load.jpg" class="lazyload" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvMjdhYzg3ZjQzOTJmMGFiOTllNGM2NWMyM2NjNzE5NDU_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ"  alt="img"></p><p>其中加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的。解析阶段可以在初始化之后再开始(运行时绑定或动态绑定或晚期绑定)。</p><p>以下五种情况必须对类进行初始化(而加载、验证、准备自然需要在此之前完成)：</p><ol><li>遇到 new、getstatic、putstatic 或 invokestatic 这 4 条字节码指令时没初始化触发初始化。使用场景：使用 new 关键字实例化对象、读取一个类的静态字段(被 final 修饰、已在编译期把结果放入常量池的静态字段除外)、调用一个类的静态方法。</li><li>使用 java.lang.reflect 包的方法对类进行反射调用的时候。</li><li>当初始化一个类的时候，如果发现其父类还没有进行初始化，则需先触发其父类的初始化。</li><li>当虚拟机启动时，用户需指定一个要加载的主类(包含 main() 方法的那个类)，虚拟机会先初始化这个主类。</li><li>当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需先触发其初始化。</li></ol><p>前面的五种方式是对一个类的主动引用，除此之外，所有引用类的方法都不会触发初始化，佳作被动引用。6.2 类的加载过程</p><p>6.2.1 加载</p><ol><li>通过一个类的全限定名来获取定义次类的二进制流(ZIP 包、网络、运算生成、JSP 生成、数据库读取)。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法去这个类的各种数据的访问入口。</li></ol><p>数组类的特殊性：数组类本身不通过类加载器创建，它是由 Java 虚拟机直接创建的。但数组类与类加载器仍然有很密切的关系，因为数组类的元素类型最终是要靠类加载器去创建的，数组创建过程如下：</p><ol><li>如果数组的组件类型是引用类型，那就递归采用类加载加载。</li><li>如果数组的组件类型不是引用类型，Java 虚拟机会把数组标记为引导类加载器关联。</li><li>数组类的可见性与他的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性将默认为 public。</li></ol><p>内存中实例的 java.lang.Class 对象存在方法区中。作为程序访问方法区中这些类型数据的外部接口。<br>加载阶段与连接阶段的部分内容是交叉进行的，但是开始时间保持先后顺序。</p><p>6.2.2 验证</p><blockquote><p>是连接的第一步，确保 Class 文件的字节流中包含的信息符合当前虚拟机要求。</p></blockquote><p>文件格式验证</p><ol><li>是否以魔数 0xCAFEBABE 开头</li><li>主、次版本号是否在当前虚拟机处理范围之内</li><li>常量池的常量是否有不被支持常量的类型（检查常量 tag 标志）</li><li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量</li><li>CONSTANT_Utf8_info 型的常量中是否有不符合 UTF8 编码的数据</li><li>Class 文件中各个部分集文件本身是否有被删除的附加的其他信息</li></ol><p>只有通过这个阶段的验证后，字节流才会进入内存的方法区进行存储，所以后面 3 个验证阶段全部是基于方法区的存储结构进行的，不再直接操作字节流。</p><p>元数据验证</p><ol><li>这个类是否有父类（除 java.lang.Object 之外）</li><li>这个类的父类是否继承了不允许被继承的类（final 修饰的类）</li><li>如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法</li><li>类中的字段、方法是否与父类产生矛盾（覆盖父类 final 字段、出现不符合规范的重载）</li></ol><p>这一阶段主要是对类的元数据信息进行语义校验，保证不存在不符合 Java 语言规范的元数据信息。</p><p>字节码验证</p><ol><li>保证任意时刻操作数栈的数据类型与指令代码序列都鞥配合工作（不会出现按照 long 类型读一个 int 型数据）</li><li>保证跳转指令不会跳转到方法体以外的字节码指令上</li><li>保证方法体中的类型转换是有效的（子类对象赋值给父类数据类型是安全的，反过来不合法的）</li></ol><p>这是整个验证过程中最复杂的一个阶段，主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。这个阶段对类的方法体进行校验分析，保证校验类的方法在运行时不会做出危害虚拟机安全的事件。</p><p>符号引用验证</p><ol><li>符号引用中通过字符创描述的全限定名是否能找到对应的类</li><li>在指定类中是否存在符方法的字段描述符以及简单名称所描述的方法和字段</li><li>符号引用中的类、字段、方法的访问性（private、protected、public、default）是否可被当前类访问</li></ol><p>最后一个阶段的校验发生在迅疾将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验，还有以上提及的内容。<br>符号引用的目的是确保解析动作能正常执行，如果无法通过符号引用验证将抛出一个 java.lang.IncompatibleClass.ChangeError 异常的子类。如 java.lang.IllegalAccessError、java.lang.NoSuchFieldError、java.lang.NoSuchMethodError 等。</p><p>6.2.3 准备</p><blockquote><p>这个阶段正式为类分配内存并设置类变量初始值，内存在方法去中分配(含 static 修饰的变量不含实例变量)。</p></blockquote><p><code>public static int value = 1127;</code><br>这句代码在初始值设置之后为 0，因为这时候尚未开始执行任何 Java 方法。而把 value 赋值为 1127 的 putstatic 指令是程序被编译后，存放于 clinit() 方法中，所以初始化阶段才会对 value 进行赋值。</p><p>基本数据类型的零值</p><table><thead><tr><th align="left">数据类型</th><th align="left">零值</th><th align="left">数据类型</th><th align="left">零值</th></tr></thead><tbody><tr><td align="left">int</td><td align="left">0</td><td align="left">boolean</td><td align="left">false</td></tr><tr><td align="left">long</td><td align="left">0L</td><td align="left">float</td><td align="left">0.0f</td></tr><tr><td align="left">short</td><td align="left">(short) 0</td><td align="left">double</td><td align="left">0.0d</td></tr><tr><td align="left">char</td><td align="left">‘\u0000’</td><td align="left">reference</td><td align="left">null</td></tr><tr><td align="left">byte</td><td align="left">(byte) 0</td><td align="left"></td><td align="left"></td></tr></tbody></table><p>特殊情况：如果类字段的字段属性表中存在 ConstantValue 属性，在准备阶段虚拟机就会根据 ConstantValue 的设置将 value 赋值为 1127。</p><p>6.2.4 解析</p><blockquote><p>这个阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p></blockquote><ol><li>符号引用<br>符号引用以一组符号来描述所引用的目标，符号可以使任何形式的字面量。</li><li>直接引用<br>直接引用可以使直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用和迅疾的内存布局实现有关</li></ol><p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 7 类符号引用进行，分别对应于常量池的 7 中常量类型。</p><p>6.2.5 初始化</p><blockquote><p>前面过程都是以虚拟机主导，而初始化阶段开始执行类中的 Java 代码。</p></blockquote><p>6.3 类加载器</p><blockquote><p>通过一个类的全限定名来获取描述此类的二进制字节流。</p></blockquote><p>6.3.1 双亲委派模型</p><blockquote><p>从 Java 虚拟机角度讲，只存在两种类加载器：一种是启动类加载器（C++ 实现，是虚拟机的一部分）；另一种是其他所有类的加载器（Java 实现，独立于虚拟机外部且全继承自 java.lang.ClassLoader）</p></blockquote><ol><li>启动类加载器<br>加载 lib 下或被 -Xbootclasspath 路径下的类</li><li>扩展类加载器<br>加载 lib/ext 或者被 java.ext.dirs 系统变量所指定的路径下的类</li><li>引用程序类加载器<br>ClassLoader负责，加载用户路径上所指定的类库。</li></ol><p><img src="https://cdn.shieldofzues.cn/2020-07-31-load.jpg" class="lazyload" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvYzQyNzA0NzNjNDJjNGE1ZDE0ZWI0NzRjOGQ5NTcwZWI_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ"  alt="img"></p><p>除顶层启动类加载器之外，其他都有自己的父类加载器。<br>工作过程：如果一个类加载器收到一个类加载的请求，它首先不会自己加载，而是把这个请求委派给父类加载器。只有父类无法完成时子类才会尝试加载。</p><p>以上内容<a href="https://blog.csdn.net/qq_41701956/article/details/81664921" target="_blank" rel="noopener">参考原文</a> 和自己的一些补充 ，后续再继续总结填补空白～～                                                                                                    </p>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
